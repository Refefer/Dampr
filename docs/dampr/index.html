<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>dampr API documentation</title>
    <meta name="description" content="Dampr is a light-weight MapReduce library for single machine computation.  It supports a number of 
..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #0000FF } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#dampr.ARReduce">ARReduce</a></span>
        
          
  <ul>
    <li class="mono"><a href="#dampr.ARReduce.__init__">__init__</a></li>
    <li class="mono"><a href="#dampr.ARReduce.first">first</a></li>
    <li class="mono"><a href="#dampr.ARReduce.reduce">reduce</a></li>
    <li class="mono"><a href="#dampr.ARReduce.sum">sum</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#dampr.BlockMapper">BlockMapper</a></span>
        
          
  <ul>
    <li class="mono"><a href="#dampr.BlockMapper.add">add</a></li>
    <li class="mono"><a href="#dampr.BlockMapper.finish">finish</a></li>
    <li class="mono"><a href="#dampr.BlockMapper.map">map</a></li>
    <li class="mono"><a href="#dampr.BlockMapper.start">start</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#dampr.BlockReducer">BlockReducer</a></span>
        
          
  <ul>
    <li class="mono"><a href="#dampr.BlockReducer.add">add</a></li>
    <li class="mono"><a href="#dampr.BlockReducer.finish">finish</a></li>
    <li class="mono"><a href="#dampr.BlockReducer.group_datasets">group_datasets</a></li>
    <li class="mono"><a href="#dampr.BlockReducer.reduce">reduce</a></li>
    <li class="mono"><a href="#dampr.BlockReducer.start">start</a></li>
    <li class="mono"><a href="#dampr.BlockReducer.yield_groups">yield_groups</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#dampr.Dampr">Dampr</a></span>
        
          
  <ul>
    <li class="mono"><a href="#dampr.Dampr.__init__">__init__</a></li>
    <li class="mono"><a href="#dampr.Dampr.from_dataset">from_dataset</a></li>
    <li class="mono"><a href="#dampr.Dampr.json">json</a></li>
    <li class="mono"><a href="#dampr.Dampr.memory">memory</a></li>
    <li class="mono"><a href="#dampr.Dampr.run">run</a></li>
    <li class="mono"><a href="#dampr.Dampr.text">text</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#dampr.PJoin">PJoin</a></span>
        
          
  <ul>
    <li class="mono"><a href="#dampr.PJoin.__init__">__init__</a></li>
    <li class="mono"><a href="#dampr.PJoin.left_reduce">left_reduce</a></li>
    <li class="mono"><a href="#dampr.PJoin.read">read</a></li>
    <li class="mono"><a href="#dampr.PJoin.reduce">reduce</a></li>
    <li class="mono"><a href="#dampr.PJoin.run">run</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#dampr.PMap">PMap</a></span>
        
          
  <ul>
    <li class="mono"><a href="#dampr.PMap.__init__">__init__</a></li>
    <li class="mono"><a href="#dampr.PMap.a_group_by">a_group_by</a></li>
    <li class="mono"><a href="#dampr.PMap.cached">cached</a></li>
    <li class="mono"><a href="#dampr.PMap.checkpoint">checkpoint</a></li>
    <li class="mono"><a href="#dampr.PMap.count">count</a></li>
    <li class="mono"><a href="#dampr.PMap.cross_left">cross_left</a></li>
    <li class="mono"><a href="#dampr.PMap.cross_right">cross_right</a></li>
    <li class="mono"><a href="#dampr.PMap.custom_mapper">custom_mapper</a></li>
    <li class="mono"><a href="#dampr.PMap.custom_reducer">custom_reducer</a></li>
    <li class="mono"><a href="#dampr.PMap.filter">filter</a></li>
    <li class="mono"><a href="#dampr.PMap.flat_map">flat_map</a></li>
    <li class="mono"><a href="#dampr.PMap.fold_by">fold_by</a></li>
    <li class="mono"><a href="#dampr.PMap.group_by">group_by</a></li>
    <li class="mono"><a href="#dampr.PMap.inspect">inspect</a></li>
    <li class="mono"><a href="#dampr.PMap.join">join</a></li>
    <li class="mono"><a href="#dampr.PMap.map">map</a></li>
    <li class="mono"><a href="#dampr.PMap.mean">mean</a></li>
    <li class="mono"><a href="#dampr.PMap.partition_map">partition_map</a></li>
    <li class="mono"><a href="#dampr.PMap.partition_reduce">partition_reduce</a></li>
    <li class="mono"><a href="#dampr.PMap.read">read</a></li>
    <li class="mono"><a href="#dampr.PMap.run">run</a></li>
    <li class="mono"><a href="#dampr.PMap.sample">sample</a></li>
    <li class="mono"><a href="#dampr.PMap.sink">sink</a></li>
    <li class="mono"><a href="#dampr.PMap.sink_json">sink_json</a></li>
    <li class="mono"><a href="#dampr.PMap.sink_tsv">sink_tsv</a></li>
    <li class="mono"><a href="#dampr.PMap.sort_by">sort_by</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#dampr.PReduce">PReduce</a></span>
        
          
  <ul>
    <li class="mono"><a href="#dampr.PReduce.__init__">__init__</a></li>
    <li class="mono"><a href="#dampr.PReduce.join">join</a></li>
    <li class="mono"><a href="#dampr.PReduce.partition_reduce">partition_reduce</a></li>
    <li class="mono"><a href="#dampr.PReduce.read">read</a></li>
    <li class="mono"><a href="#dampr.PReduce.reduce">reduce</a></li>
    <li class="mono"><a href="#dampr.PReduce.run">run</a></li>
    <li class="mono"><a href="#dampr.PReduce.unique">unique</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">dampr</span> module</h1>
  <p>Dampr is a light-weight MapReduce library for single machine computation.  It supports a number of 
useful features such as map and reduce side joins, associative reduces, 
aggregations, multiprocessing, and more.  It operates by default out-of-core, allowing
processing of 100s of gbs to tbs of data on a single machine.</p>
<p>While the underlying engine uses the MapReduce paradigm for processing, Dampr is 
best utilized via it's DSL which provides higher level functionality for complex workflows.</p>
<p>It loosely attempts to replicate interfaces such as Spark or Scalding for ease of pickup.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr', this);">Show source &equiv;</a></p>
  <div id="source-dampr" class="source">
    <div class="codehilite"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Dampr is a light-weight MapReduce library for single machine computation.  It supports a number of </span>
<span class="sd">useful features such as map and reduce side joins, associative reduces, </span>
<span class="sd">aggregations, multiprocessing, and more.  It operates by default out-of-core, allowing</span>
<span class="sd">processing of 100s of gbs to tbs of data on a single machine.</span>

<span class="sd">While the underlying engine uses the MapReduce paradigm for processing, Dampr is </span>
<span class="sd">best utilized via it&#39;s DSL which provides higher level functionality for complex workflows.</span>

<span class="sd">It loosely attempts to replicate interfaces such as Spark or Scalding for ease of pickup.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">.dampr</span> <span class="kn">import</span> <span class="n">Dampr</span><span class="p">,</span> <span class="n">PMap</span><span class="p">,</span> <span class="n">PReduce</span><span class="p">,</span> <span class="n">PJoin</span><span class="p">,</span> <span class="n">ARReduce</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">BlockMapper</span><span class="p">,</span> <span class="n">BlockReducer</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Dampr&quot;</span><span class="p">,</span> <span class="s2">&quot;PMap&quot;</span><span class="p">,</span> <span class="s2">&quot;PReduce&quot;</span><span class="p">,</span> <span class="s2">&quot;PJoin&quot;</span><span class="p">,</span> <span class="s2">&quot;ARReduce&quot;</span><span class="p">,</span> 
        <span class="s2">&quot;BlockMapper&quot;</span><span class="p">,</span> <span class="s2">&quot;BlockReducer&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">setup_logging</span><span class="p">(</span><span class="n">loglevel</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience function for enabling logging</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">loglevel</span><span class="p">,</span>
                        <span class="n">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> </span><span class="si">%(levelname)s</span><span class="s1"> </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="dampr.ARReduce" class="name">class <span class="ident">ARReduce</span></p>
      
  
    <div class="desc"><p>Associative Reducer operators.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.ARReduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.ARReduce" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">ARReduce</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Associative Reducer operators.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pmap</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pmap</span> <span class="o">=</span> <span class="n">pmap</span>

    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binop</span><span class="p">,</span> <span class="n">reduce_buffer</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduces a grouped dataset by an associative binary operator.</span>
<span class="sd">        This will do a partial reduce in the map stage, completing the reduction</span>
<span class="sd">        in the reduce stage.  It is often substantially faster than the more</span>
<span class="sd">        general group_by.</span>

<span class="sd">        `reduce_buffer` is a constant which tells Dampr how much temporary storage</span>
<span class="sd">        to keep in memory on the map side reductions.  For example with `1000`, Dampr</span>
<span class="sd">        will keep 1000 unique keys in memory.  In the case where a new key would spill</span>
<span class="sd">        over the buffer size, Dampr will flush the buffer to disk and create a new</span>
<span class="sd">        buffer.  By increasing the `reduce_buffer`, you can increase efficiency while</span>
<span class="sd">        sacrificing memory.</span>

<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: 1).reduce(lambda x, y: x + y).read()</span>
<span class="sd">            [(1, 15)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">vs</span><span class="p">):</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vs</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">binop</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">acc</span>

        <span class="n">red</span> <span class="o">=</span> <span class="n">Reduce</span><span class="p">(</span><span class="n">_reduce</span><span class="p">)</span>
        <span class="n">options</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;binop&quot;</span><span class="p">:</span> <span class="n">binop</span><span class="p">,</span> <span class="s2">&quot;reduce_buffer&quot;</span><span class="p">:</span> <span class="n">reduce_buffer</span><span class="p">})</span>
        <span class="c1"># We add the associative aggregator to the combiner during map</span>
        <span class="n">pm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmap</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> 
                <span class="n">combiner</span><span class="o">=</span><span class="n">PartialReduceCombiner</span><span class="p">(</span><span class="n">red</span><span class="p">),</span> 
                <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PReduce</span><span class="p">(</span><span class="n">pm</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">pm</span><span class="o">.</span><span class="n">pmer</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">_reduce</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the first item found for a given key. </span>
<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).first().read()</span>
<span class="sd">            [(0, 2), (1, 1)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">_y</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simple sum of values by key.</span>

<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).sum().read()</span>
<span class="sd">            [(0, 6), (1, 9)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#dampr.ARReduce">ARReduce</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="dampr.ARReduce.pmap" class="name">var <span class="ident">pmap</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="dampr.ARReduce.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, pmap)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.ARReduce.__init__', this);">Show source &equiv;</a></p>
  <div id="source-dampr.ARReduce.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pmap</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pmap</span> <span class="o">=</span> <span class="n">pmap</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.ARReduce.first">
    <p>def <span class="ident">first</span>(</p><p>self, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the first item found for a given key. </p>
<blockquote>
<blockquote>
<blockquote>
<p>Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).first().read()
[(0, 2), (1, 1)]</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.ARReduce.first', this);">Show source &equiv;</a></p>
  <div id="source-dampr.ARReduce.first" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the first item found for a given key. </span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).first().read()</span>
<span class="sd">        [(0, 2), (1, 1)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">_y</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.ARReduce.reduce">
    <p>def <span class="ident">reduce</span>(</p><p>self, binop, reduce_buffer=1000, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Reduces a grouped dataset by an associative binary operator.
This will do a partial reduce in the map stage, completing the reduction
in the reduce stage.  It is often substantially faster than the more
general group_by.</p>
<p><code>reduce_buffer</code> is a constant which tells Dampr how much temporary storage
to keep in memory on the map side reductions.  For example with <code>1000</code>, Dampr
will keep 1000 unique keys in memory.  In the case where a new key would spill
over the buffer size, Dampr will flush the buffer to disk and create a new
buffer.  By increasing the <code>reduce_buffer</code>, you can increase efficiency while
sacrificing memory.</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: 1).reduce(lambda x, y: x + y).read()
[(1, 15)]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.ARReduce.reduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.ARReduce.reduce" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binop</span><span class="p">,</span> <span class="n">reduce_buffer</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reduces a grouped dataset by an associative binary operator.</span>
<span class="sd">    This will do a partial reduce in the map stage, completing the reduction</span>
<span class="sd">    in the reduce stage.  It is often substantially faster than the more</span>
<span class="sd">    general group_by.</span>
<span class="sd">    `reduce_buffer` is a constant which tells Dampr how much temporary storage</span>
<span class="sd">    to keep in memory on the map side reductions.  For example with `1000`, Dampr</span>
<span class="sd">    will keep 1000 unique keys in memory.  In the case where a new key would spill</span>
<span class="sd">    over the buffer size, Dampr will flush the buffer to disk and create a new</span>
<span class="sd">    buffer.  By increasing the `reduce_buffer`, you can increase efficiency while</span>
<span class="sd">    sacrificing memory.</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: 1).reduce(lambda x, y: x + y).read()</span>
<span class="sd">        [(1, 15)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">vs</span><span class="p">):</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vs</span><span class="p">:</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="n">binop</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">acc</span>
    <span class="n">red</span> <span class="o">=</span> <span class="n">Reduce</span><span class="p">(</span><span class="n">_reduce</span><span class="p">)</span>
    <span class="n">options</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;binop&quot;</span><span class="p">:</span> <span class="n">binop</span><span class="p">,</span> <span class="s2">&quot;reduce_buffer&quot;</span><span class="p">:</span> <span class="n">reduce_buffer</span><span class="p">})</span>
    <span class="c1"># We add the associative aggregator to the combiner during map</span>
    <span class="n">pm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmap</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> 
            <span class="n">combiner</span><span class="o">=</span><span class="n">PartialReduceCombiner</span><span class="p">(</span><span class="n">red</span><span class="p">),</span> 
            <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PReduce</span><span class="p">(</span><span class="n">pm</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">pm</span><span class="o">.</span><span class="n">pmer</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">_reduce</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.ARReduce.sum">
    <p>def <span class="ident">sum</span>(</p><p>self, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Simple sum of values by key.</p>
<blockquote>
<blockquote>
<blockquote>
<p>Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).sum().read()
[(0, 6), (1, 9)]</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.ARReduce.sum', this);">Show source &equiv;</a></p>
  <div id="source-dampr.ARReduce.sum" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple sum of values by key.</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).sum().read()</span>
<span class="sd">        [(0, 6), (1, 9)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="dampr.BlockMapper" class="name">class <span class="ident">BlockMapper</span></p>
      
  
    <div class="desc"><p>Custom BlockMapper.  User's can specify how a Mapper instance can
consume a stream of key-values, allowing for custom logic.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockMapper', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockMapper" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">BlockMapper</span><span class="p">(</span><span class="n">Mapper</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Custom BlockMapper.  User&#39;s can specify how a Mapper instance can</span>
<span class="sd">    consume a stream of key-values, allowing for custom logic.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets up instance variables for when a Mapper begins consumption of </span>
<span class="sd">        a Map Block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logic for how to handle new key-value pairs.  This function is required</span>
<span class="sd">        to return an iterator regardless of whether it yields data: this gives</span>
<span class="sd">        a more flexible definition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mapping is finished.  In the case of aggregations, this should yield out</span>
<span class="sd">        all remaining key-values for Polymr to consume.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">datasets</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">out</span>

        <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">finish</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">out</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#dampr.BlockMapper">BlockMapper</a></li>
          <li>dampr.base.Mapper</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="dampr.BlockMapper.add">
    <p>def <span class="ident">add</span>(</p><p>self, key, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Logic for how to handle new key-value pairs.  This function is required
to return an iterator regardless of whether it yields data: this gives
a more flexible definition.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockMapper.add', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockMapper.add" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logic for how to handle new key-value pairs.  This function is required</span>
<span class="sd">    to return an iterator regardless of whether it yields data: this gives</span>
<span class="sd">    a more flexible definition.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockMapper.finish">
    <p>def <span class="ident">finish</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Mapping is finished.  In the case of aggregations, this should yield out
all remaining key-values for Polymr to consume.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockMapper.finish', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockMapper.finish" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mapping is finished.  In the case of aggregations, this should yield out</span>
<span class="sd">    all remaining key-values for Polymr to consume.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockMapper.map">
    <p>def <span class="ident">map</span>(</p><p>self, *datasets)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockMapper.map', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockMapper.map" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">datasets</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">out</span>
    <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">finish</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">out</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockMapper.start">
    <p>def <span class="ident">start</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets up instance variables for when a Mapper begins consumption of 
a Map Block.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockMapper.start', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockMapper.start" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets up instance variables for when a Mapper begins consumption of </span>
<span class="sd">    a Map Block.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="dampr.BlockReducer" class="name">class <span class="ident">BlockReducer</span></p>
      
  
    <div class="desc"><p>Custom BlockReducer.  User's can specify how a Reducer instance can
consume a stream of key-valueiters, allowing for custom logic.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockReducer', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockReducer" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">BlockReducer</span><span class="p">(</span><span class="n">Reducer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Custom BlockReducer.  User&#39;s can specify how a Reducer instance can</span>
<span class="sd">    consume a stream of key-valueiters, allowing for custom logic.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span> 

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">it</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">datasets</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">vs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_groups</span><span class="p">(</span><span class="n">datasets</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">nk</span><span class="p">,</span> <span class="n">nv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">vs</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">nk</span><span class="p">,</span> <span class="n">nv</span>

        <span class="k">for</span> <span class="n">nk</span><span class="p">,</span> <span class="n">nv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">finish</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">nk</span><span class="p">,</span> <span class="n">nv</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#dampr.BlockReducer">BlockReducer</a></li>
          <li>dampr.base.Reducer</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="dampr.BlockReducer.add">
    <p>def <span class="ident">add</span>(</p><p>self, k, it)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockReducer.add', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockReducer.add" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">it</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockReducer.finish">
    <p>def <span class="ident">finish</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockReducer.finish', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockReducer.finish" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockReducer.group_datasets">
    <p>def <span class="ident">group_datasets</span>(</p><p>self, dataset)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockReducer.group_datasets', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockReducer.group_datasets" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">group_datasets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">MergeDataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">EmptyDataset</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">dataset</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockReducer.reduce">
    <p>def <span class="ident">reduce</span>(</p><p>self, *datasets)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockReducer.reduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockReducer.reduce" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">datasets</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">vs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_groups</span><span class="p">(</span><span class="n">datasets</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">nk</span><span class="p">,</span> <span class="n">nv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">vs</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">nk</span><span class="p">,</span> <span class="n">nv</span>
    <span class="k">for</span> <span class="n">nk</span><span class="p">,</span> <span class="n">nv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">finish</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">nk</span><span class="p">,</span> <span class="n">nv</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockReducer.start">
    <p>def <span class="ident">start</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockReducer.start', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockReducer.start" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span> 
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockReducer.yield_groups">
    <p>def <span class="ident">yield_groups</span>(</p><p>self, dataset)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockReducer.yield_groups', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockReducer.yield_groups" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">yield_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_datasets</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span><span class="o">.</span><span class="n">grouped_read</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="dampr.Dampr" class="name">class <span class="ident">Dampr</span></p>
      
  
    <div class="desc"><p>Entrypoint into the Dampr processing functions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.Dampr', this);">Show source &equiv;</a></p>
  <div id="source-dampr.Dampr" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Dampr</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Entrypoint into the Dampr processing functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">runner</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span> 
        <span class="k">if</span> <span class="n">runner</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">runner</span> <span class="o">=</span> <span class="n">MTRunner</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">runner</span> <span class="o">=</span> <span class="n">runner</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">memory</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">partitions</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an in-memory dataset from the provided items.  `partitions` define how</span>
<span class="sd">        many initial functions there will be.</span>

<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="n">MemoryInput</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">)),</span> <span class="n">partitions</span><span class="p">)</span>
        <span class="n">source</span><span class="p">,</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">mi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">Dampr</span><span class="p">(</span><span class="n">ng</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">text</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="mi">16</span><span class="o">*</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads a file or directory of files into Dampr.  Each record is assumed to </span>
<span class="sd">        be newline delimited.  </span>

<span class="sd">        When fname is a directory, it will walk the directory, collecting all</span>
<span class="sd">        files within it as part of the collection.</span>
<span class="sd">        </span>
<span class="sd">        `chunk_size` describes how big each map portion will be.</span>

<span class="sd">        Returns a PMap object.</span>

<span class="sd">            &gt;&gt;&gt; Dampr.text(&#39;/tmp&#39;, chunk_size=64*1024**2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="n">DirectoryInput</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="n">TextInput</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">)</span>

        <span class="n">source</span><span class="p">,</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">Dampr</span><span class="p">(</span><span class="n">ng</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function which reads newline-delimited json records.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dataset</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Typically not used, this will read the raw outputs of a Dampr stage </span>
<span class="sd">        as an input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">Chunker</span><span class="p">)</span>
        <span class="n">source</span><span class="p">,</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">Dampr</span><span class="p">(</span><span class="n">ng</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">pmers</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs a graph or set of graphs.</span>

<span class="sd">            &gt;&gt;&gt; foo = Dampr.memory([1,2,3,4,5])</span>
<span class="sd">            &gt;&gt;&gt; bar = Dampr.memory([6,7,8,9,10])</span>
<span class="sd">            &gt;&gt;&gt; left, right = Dampr.run(foo, bar)</span>
<span class="sd">            &gt;&gt;&gt; left.read()</span>
<span class="sd">            [1, 2, 3, 4, 5]</span>
<span class="sd">            &gt;&gt;&gt; right.read()</span>
<span class="sd">            [6, 7, 8, 9, 10]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pmer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pmers</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pmer</span><span class="p">,</span> <span class="n">PMap</span><span class="p">):</span>
                <span class="n">pmer</span> <span class="o">=</span> <span class="n">pmer</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pmer</span><span class="p">,</span> <span class="n">PJoin</span><span class="p">):</span>
                <span class="n">pmer</span> <span class="o">=</span> <span class="n">pmer</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)))</span>
            
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">graph</span> <span class="o">=</span> <span class="n">pmer</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">graph</span> <span class="o">=</span> <span class="n">pmer</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

            <span class="n">sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pmer</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>

        <span class="n">name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;dampr/{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()))</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">pmer</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">runner</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ValueEmitter</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_add_mapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> 
        <span class="n">output</span><span class="p">,</span> <span class="n">ng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_mapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">Dampr</span><span class="p">(</span><span class="n">ng</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_reducer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> 
        <span class="n">output</span><span class="p">,</span> <span class="n">ng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_reducer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">Dampr</span><span class="p">(</span><span class="n">ng</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_sink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> 
        <span class="n">output</span><span class="p">,</span> <span class="n">ng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_sink</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">Dampr</span><span class="p">(</span><span class="n">ng</span><span class="p">)</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#dampr.Dampr">Dampr</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="dampr.Dampr.graph" class="name">var <span class="ident">graph</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="dampr.Dampr.runner" class="name">var <span class="ident">runner</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="dampr.Dampr.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, graph=None, runner=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.Dampr.__init__', this);">Show source &equiv;</a></p>
  <div id="source-dampr.Dampr.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">runner</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span> 
    <span class="k">if</span> <span class="n">runner</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">runner</span> <span class="o">=</span> <span class="n">MTRunner</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">runner</span> <span class="o">=</span> <span class="n">runner</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.Dampr.from_dataset">
    <p>def <span class="ident">from_dataset</span>(</p><p>cls, dataset)</p>
    </div>
    

    
  
    <div class="desc"><p>Typically not used, this will read the raw outputs of a Dampr stage 
as an input.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.Dampr.from_dataset', this);">Show source &equiv;</a></p>
  <div id="source-dampr.Dampr.from_dataset" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_dataset</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Typically not used, this will read the raw outputs of a Dampr stage </span>
<span class="sd">    as an input.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">Chunker</span><span class="p">)</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">Dampr</span><span class="p">(</span><span class="n">ng</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.Dampr.json">
    <p>def <span class="ident">json</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Convenience function which reads newline-delimited json records.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.Dampr.json', this);">Show source &equiv;</a></p>
  <div id="source-dampr.Dampr.json" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience function which reads newline-delimited json records.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.Dampr.memory">
    <p>def <span class="ident">memory</span>(</p><p>cls, items, partitions=50)</p>
    </div>
    

    
  
    <div class="desc"><p>Create an in-memory dataset from the provided items.  <code>partitions</code> define how
many initial functions there will be.</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5])
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.Dampr.memory', this);">Show source &equiv;</a></p>
  <div id="source-dampr.Dampr.memory" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">memory</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">partitions</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an in-memory dataset from the provided items.  `partitions` define how</span>
<span class="sd">    many initial functions there will be.</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mi</span> <span class="o">=</span> <span class="n">MemoryInput</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">)),</span> <span class="n">partitions</span><span class="p">)</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">mi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">Dampr</span><span class="p">(</span><span class="n">ng</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.Dampr.run">
    <p>def <span class="ident">run</span>(</p><p>self, *pmers, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Runs a graph or set of graphs.</p>
<blockquote>
<blockquote>
<blockquote>
<p>foo = Dampr.memory([1,2,3,4,5])
bar = Dampr.memory([6,7,8,9,10])
left, right = Dampr.run(foo, bar)
left.read()
[1, 2, 3, 4, 5]
right.read()
[6, 7, 8, 9, 10]</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.Dampr.run', this);">Show source &equiv;</a></p>
  <div id="source-dampr.Dampr.run" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">pmers</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Runs a graph or set of graphs.</span>
<span class="sd">        &gt;&gt;&gt; foo = Dampr.memory([1,2,3,4,5])</span>
<span class="sd">        &gt;&gt;&gt; bar = Dampr.memory([6,7,8,9,10])</span>
<span class="sd">        &gt;&gt;&gt; left, right = Dampr.run(foo, bar)</span>
<span class="sd">        &gt;&gt;&gt; left.read()</span>
<span class="sd">        [1, 2, 3, 4, 5]</span>
<span class="sd">        &gt;&gt;&gt; right.read()</span>
<span class="sd">        [6, 7, 8, 9, 10]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sources</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pmer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pmers</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pmer</span><span class="p">,</span> <span class="n">PMap</span><span class="p">):</span>
            <span class="n">pmer</span> <span class="o">=</span> <span class="n">pmer</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pmer</span><span class="p">,</span> <span class="n">PJoin</span><span class="p">):</span>
            <span class="n">pmer</span> <span class="o">=</span> <span class="n">pmer</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)))</span>
        
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">pmer</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">pmer</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pmer</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;dampr/{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()))</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">pmer</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">runner</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ValueEmitter</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">]</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.Dampr.text">
    <p>def <span class="ident">text</span>(</p><p>cls, fname, chunk_size=16777216)</p>
    </div>
    

    
  
    <div class="desc"><p>Reads a file or directory of files into Dampr.  Each record is assumed to 
be newline delimited.  </p>
<p>When fname is a directory, it will walk the directory, collecting all
files within it as part of the collection.</p>
<p><code>chunk_size</code> describes how big each map portion will be.</p>
<p>Returns a PMap object.</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; Dampr.text(&#39;/tmp&#39;, chunk_size=64*1024**2)
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.Dampr.text', this);">Show source &equiv;</a></p>
  <div id="source-dampr.Dampr.text" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">text</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="mi">16</span><span class="o">*</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads a file or directory of files into Dampr.  Each record is assumed to </span>
<span class="sd">    be newline delimited.  </span>
<span class="sd">    When fname is a directory, it will walk the directory, collecting all</span>
<span class="sd">    files within it as part of the collection.</span>
<span class="sd">    </span>
<span class="sd">    `chunk_size` describes how big each map portion will be.</span>
<span class="sd">    Returns a PMap object.</span>
<span class="sd">        &gt;&gt;&gt; Dampr.text(&#39;/tmp&#39;, chunk_size=64*1024**2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="n">DirectoryInput</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="n">TextInput</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">)</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">Dampr</span><span class="p">(</span><span class="n">ng</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="dampr.PJoin" class="name">class <span class="ident">PJoin</span></p>
      
  
    <div class="desc"><p>Performs different types of joins between two grouped datasets.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PJoin', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PJoin" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PJoin</span><span class="p">(</span><span class="n">PBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs different types of joins between two grouped datasets.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PJoin</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)))</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">,</span> <span class="n">many</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs an inner join between two datasets.  The aggregate function</span>
<span class="sd">        will be provied two arguments: the left iterator and the right iterator.</span>


<span class="sd">            &gt;&gt;&gt; left = Dampr.memory([(&quot;foo&quot;, 13), (&quot;bar&quot;, 14)]).group_by(lambda x: x[0])</span>
<span class="sd">            &gt;&gt;&gt; right = Dampr.memory([(&quot;bar&quot;, &quot;baller&quot;), (&quot;baz&quot;, &quot;bag&quot;)]).group_by(lambda x: x[0])</span>
<span class="sd">            &gt;&gt;&gt; left.join(right).reduce(lambda lit, rit: (list(lit), list(rit))).read()</span>
<span class="sd">            [(&#39;bar&#39;, ([(&#39;bar&#39;, 14)], [(&#39;bar&#39;, &#39;baller&#39;)]))]</span>


<span class="sd">        If `many` is True, reduce will flatten the output into seperate records:</span>

<span class="sd">            &gt;&gt;&gt; left.join(right).reduce(lambda lit, rit: list(lit) + list(rit), many=True).read()</span>
<span class="sd">            [(&#39;bar&#39;, (&#39;bar&#39;, 14)), (&#39;bar&#39;, (&#39;bar&#39;, &#39;baller&#39;))]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">aggregate</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

        <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_reducer</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">],</span> 
                <span class="n">KeyedInnerJoin</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">many</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">left_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a left join on two datasets.  In the case where the right dataset</span>
<span class="sd">        is missing the join key, it will call the aggregate function with an empty</span>
<span class="sd">        iterator.</span>

<span class="sd">            &gt;&gt;&gt; left = Dampr.memory([(&quot;foo&quot;, 13), (&quot;bar&quot;, 14)]).group_by(lambda x: x[0])</span>
<span class="sd">            &gt;&gt;&gt; right = Dampr.memory([(&quot;bar&quot;, &quot;baller&quot;), (&quot;baz&quot;, &quot;bag&quot;)]).group_by(lambda x: x[0])</span>
<span class="sd">            &gt;&gt;&gt; left.join(right).left_reduce(lambda lit, rit: (list(lit), list(rit))).read()</span>
<span class="sd">            [(&#39;bar&#39;, ([(&#39;bar&#39;, 14)], [(&#39;bar&#39;, &#39;baller&#39;)])), (&#39;foo&#39;, ([(&#39;foo&#39;, 13)], []))]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">aggregate</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

        <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_reducer</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">],</span> 
                <span class="n">KeyedLeftJoin</span><span class="p">(</span><span class="n">_reduce</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crosser</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_cross</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">k1</span><span class="p">,</span> <span class="n">crosser</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

        <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_reducer</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">],</span>
                <span class="n">KeyedCrossJoin</span><span class="p">(</span><span class="n">_cross</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#dampr.PJoin">PJoin</a></li>
          <li>dampr.dampr.PBase</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="dampr.PJoin.right" class="name">var <span class="ident">right</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="dampr.PJoin.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, source, pmer, right)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PJoin.__init__', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PJoin.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">PJoin</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PJoin.left_reduce">
    <p>def <span class="ident">left_reduce</span>(</p><p>self, aggregate)</p>
    </div>
    

    
  
    <div class="desc"><p>Performs a left join on two datasets.  In the case where the right dataset
is missing the join key, it will call the aggregate function with an empty
iterator.</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; left = Dampr.memory([(&quot;foo&quot;, 13), (&quot;bar&quot;, 14)]).group_by(lambda x: x[0])
&gt;&gt;&gt; right = Dampr.memory([(&quot;bar&quot;, &quot;baller&quot;), (&quot;baz&quot;, &quot;bag&quot;)]).group_by(lambda x: x[0])
&gt;&gt;&gt; left.join(right).left_reduce(lambda lit, rit: (list(lit), list(rit))).read()
[(&#39;bar&#39;, ([(&#39;bar&#39;, 14)], [(&#39;bar&#39;, &#39;baller&#39;)])), (&#39;foo&#39;, ([(&#39;foo&#39;, 13)], []))]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PJoin.left_reduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PJoin.left_reduce" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">left_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs a left join on two datasets.  In the case where the right dataset</span>
<span class="sd">    is missing the join key, it will call the aggregate function with an empty</span>
<span class="sd">    iterator.</span>
<span class="sd">        &gt;&gt;&gt; left = Dampr.memory([(&quot;foo&quot;, 13), (&quot;bar&quot;, 14)]).group_by(lambda x: x[0])</span>
<span class="sd">        &gt;&gt;&gt; right = Dampr.memory([(&quot;bar&quot;, &quot;baller&quot;), (&quot;baz&quot;, &quot;bag&quot;)]).group_by(lambda x: x[0])</span>
<span class="sd">        &gt;&gt;&gt; left.join(right).left_reduce(lambda lit, rit: (list(lit), list(rit))).read()</span>
<span class="sd">        [(&#39;bar&#39;, ([(&#39;bar&#39;, 14)], [(&#39;bar&#39;, &#39;baller&#39;)])), (&#39;foo&#39;, ([(&#39;foo&#39;, 13)], []))]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">aggregate</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_reducer</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">],</span> 
            <span class="n">KeyedLeftJoin</span><span class="p">(</span><span class="n">_reduce</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PJoin.read">
    <p>def <span class="ident">read</span>(</p><p>self, k=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Shorthand for run() followed by a read()</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PJoin.read', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PJoin.read" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shorthand for run() followed by a read()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PJoin.reduce">
    <p>def <span class="ident">reduce</span>(</p><p>self, aggregate, many=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Performs an inner join between two datasets.  The aggregate function
will be provied two arguments: the left iterator and the right iterator.</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; left = Dampr.memory([(&quot;foo&quot;, 13), (&quot;bar&quot;, 14)]).group_by(lambda x: x[0])
&gt;&gt;&gt; right = Dampr.memory([(&quot;bar&quot;, &quot;baller&quot;), (&quot;baz&quot;, &quot;bag&quot;)]).group_by(lambda x: x[0])
&gt;&gt;&gt; left.join(right).reduce(lambda lit, rit: (list(lit), list(rit))).read()
[(&#39;bar&#39;, ([(&#39;bar&#39;, 14)], [(&#39;bar&#39;, &#39;baller&#39;)]))]
</pre></div>


<p>If <code>many</code> is True, reduce will flatten the output into seperate records:</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; left.join(right).reduce(lambda lit, rit: list(lit) + list(rit), many=True).read()
[(&#39;bar&#39;, (&#39;bar&#39;, 14)), (&#39;bar&#39;, (&#39;bar&#39;, &#39;baller&#39;))]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PJoin.reduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PJoin.reduce" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">,</span> <span class="n">many</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs an inner join between two datasets.  The aggregate function</span>
<span class="sd">    will be provied two arguments: the left iterator and the right iterator.</span>
<span class="sd">        &gt;&gt;&gt; left = Dampr.memory([(&quot;foo&quot;, 13), (&quot;bar&quot;, 14)]).group_by(lambda x: x[0])</span>
<span class="sd">        &gt;&gt;&gt; right = Dampr.memory([(&quot;bar&quot;, &quot;baller&quot;), (&quot;baz&quot;, &quot;bag&quot;)]).group_by(lambda x: x[0])</span>
<span class="sd">        &gt;&gt;&gt; left.join(right).reduce(lambda lit, rit: (list(lit), list(rit))).read()</span>
<span class="sd">        [(&#39;bar&#39;, ([(&#39;bar&#39;, 14)], [(&#39;bar&#39;, &#39;baller&#39;)]))]</span>
<span class="sd">    If `many` is True, reduce will flatten the output into seperate records:</span>
<span class="sd">        &gt;&gt;&gt; left.join(right).reduce(lambda lit, rit: list(lit) + list(rit), many=True).read()</span>
<span class="sd">        [(&#39;bar&#39;, (&#39;bar&#39;, 14)), (&#39;bar&#39;, (&#39;bar&#39;, &#39;baller&#39;))]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">aggregate</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_reducer</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">],</span> 
            <span class="n">KeyedInnerJoin</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">many</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PJoin.run">
    <p>def <span class="ident">run</span>(</p><p>self, name=None, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PJoin.run', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PJoin.run" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)))</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="dampr.PMap" class="name">class <span class="ident">PMap</span></p>
      
  
    <div class="desc"><p>Represents most mapping processes.  Internally, it collects consecutive mapping operations
and fuses them together into a single operation, speeding up many types of operations.</p>
<p>This class shouldn't be intialized manually.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PMap</span><span class="p">(</span><span class="n">PBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents most mapping processes.  Internally, it collects consecutive mapping operations</span>
<span class="sd">    and fuses them together into a single operation, speeding up many types of operations.</span>

<span class="sd">    This class shouldn&#39;t be intialized manually.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">,</span> <span class="n">agg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PMap</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agg</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">agg</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">agg</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the defined graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">agg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">PMap</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">agg</span> <span class="o">+</span> <span class="p">[</span><span class="n">Map</span><span class="p">(</span><span class="n">f</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Samples data with a given probability.  For example:</span>
<span class="sd">        </span>
<span class="sd">        `graph.sample(0.1)` will uniformly sample 10% of the data in the collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">prob</span> <span class="o">&lt;=</span> <span class="mf">1.0</span>

        <span class="k">def</span> <span class="nf">_sample</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">get_rand</span><span class="p">()</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">prob</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_sample</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">combiner</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checkpoint forces Dampr to fuse all cached maps and add it as a MR stage.</span>

<span class="sd">        This is useful when sharing the results of a computation with multiple other graphs.</span>
<span class="sd">        </span>
<span class="sd">        Without checkpoint(), Dampr would execute the shared graph multiple times rather than reuse</span>
<span class="sd">        the results of the computation:</span>

<span class="sd">            &gt;&gt;&gt; evens = Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 0).checkpoint()</span>
<span class="sd">            &gt;&gt;&gt; summed = evens.group_by(lambda x: 1).sum()</span>
<span class="sd">            &gt;&gt;&gt; multiplied = evens.group_by(lambda x: 1).reduce(lambda x, y: x * y)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">agg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">force</span><span class="p">:</span>
            <span class="n">aggs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Map</span><span class="p">(</span><span class="n">_identity</span><span class="p">)]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">agg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">agg</span><span class="p">[:]</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39; -&gt; &#39;</span> <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">aggs</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Stage {}: </span><span class="si">%s</span><span class="s1"> =&gt; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_mapper</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">],</span> 
                    <span class="n">Map</span><span class="p">(</span><span class="n">fuse</span><span class="p">(</span><span class="n">aggs</span><span class="p">)),</span> 
                    <span class="n">combiner</span><span class="o">=</span><span class="n">combiner</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span> 

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">custom_mapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom Mapper provides a low-level interface to the underlying map function.</span>
<span class="sd">        Users can provide any instance which adhere&#39;s to the Mapper interface, allowing</span>
<span class="sd">        for powerful or specific implementations.</span>

<span class="sd">        This is typically used very rarely and has some caveats such as not fusing</span>
<span class="sd">        with other Mappers.  Similarly, the implementer needs to understand more of the</span>
<span class="sd">        nuances associated with keys.</span>

<span class="sd">            &gt;&gt;&gt; from dampr.base import Map</span>
<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).custom_mapper(Map(lambda k, x: [(k, x+1)])).read()</span>
<span class="sd">            [2, 3, 4, 5, 6]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">Mapper</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
        <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
        <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_mapper</span><span class="p">([</span><span class="n">me</span><span class="o">.</span><span class="n">source</span><span class="p">],</span> 
                <span class="n">mapper</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">custom_reducer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reducer</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allows the user to provide any Reducer which adheres to the Reducer interface.</span>
<span class="sd">        This is a very powerful, low-level interface which should be avoided when possible</span>
<span class="sd">        as it&#39;s easy to write bugs.</span>

<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).custom_reducer(Reduce(lambda k, x: [(k, sum(x))])).read()</span>
<span class="sd">            [[(0, 1)], [(1, 2)], [(2, 3)], [(3, 4)], [(4, 5)]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="n">Reducer</span><span class="p">)</span>
        <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">reducer</span><span class="p">)</span>
        <span class="n">new_source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="n">me</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_reducer</span><span class="p">([</span><span class="n">me</span><span class="o">.</span><span class="n">source</span><span class="p">],</span> 
                <span class="n">reducer</span><span class="p">,</span> 
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">new_source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">partition_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides a medium-level interface for writing custom functionality for mapping </span>
<span class="sd">        a partition.  This can be used for creating custom logic in mappers for the sake</span>
<span class="sd">        of performance or additional functionality.</span>

<span class="sd">        `f` is a function that takes in an iterator of items in the partition and yields </span>
<span class="sd">        out group keys and new values.</span>


<span class="sd">            &gt;&gt;&gt; def plus_one(items):</span>
<span class="sd">            ...   for num in items:</span>
<span class="sd">            ...     yield num, num + 1</span>
<span class="sd">            ...</span>
<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).partition_map(plus_one).read()</span>
<span class="sd">            [2, 3, 4, 5, 6]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_mapper</span><span class="p">(</span><span class="n">StreamMapper</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">partition_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        `partition_reduce` is a medium-level function that allows for more complex logic</span>
<span class="sd">        during reductions.  It can be useful in certain cases where reductions over sets</span>
<span class="sd">        of reduced values is convenient, such as returning only the top K items in a dataset</span>

<span class="sd">            &gt;&gt;&gt; def largest_number(it):</span>
<span class="sd">            ...   largest = float(&#39;-inf&#39;)</span>
<span class="sd">            ...   for group_key, its in it:</span>
<span class="sd">            ...     for value in its:</span>
<span class="sd">            ...       largest = max(largest, value)</span>
<span class="sd">            ...   yield &quot;Largest&quot;, largest</span>
<span class="sd">            ...</span>
<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).partition_reduce(largest_number).read(n_partitions=1)</span>
<span class="sd">            [(&#39;Largest&#39;, 5)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_reducer</span><span class="p">(</span><span class="n">StreamReducer</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maps elements in the underlying collection using function </span>
<span class="sd">        `f`:</span>

<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).map(lambda x: x + 1).read()</span>
<span class="sd">            [2, 3, 4, 5, 6]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_map</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filters items from a collection based on a predicate f.</span>
<span class="sd">        A predicate return True keeps the item.</span>

<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 1).read()</span>
<span class="sd">            [1, 3, 5]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_filter</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_filter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flat_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maps elements in the underlying collection using function f, </span>
<span class="sd">        flattening the results</span>

<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).flat_map(range).read()</span>
<span class="sd">            [0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_flat_map</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">vi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">vi</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_flat_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">vf</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Groups a collections of X by a key function, optionally mapping X to Y </span>
<span class="sd">        using `vf`.  Returns a Reducer object for different types of aggregations</span>

<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).group_by(lambda x: x % 2).reduce(lambda k, it: sum(it)).read()</span>
<span class="sd">            [(0, 6), (1, 9)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_group_by</span><span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">key</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">vf</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="n">pm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_group_by</span><span class="p">)</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">PReduce</span><span class="p">(</span><span class="n">pm</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">pm</span><span class="o">.</span><span class="n">pmer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">a_group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">vf</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Groups a collection of X by a key function and optionally mapping X to Y</span>
<span class="sd">        using `vf`.  It differs from `group_by` by requiring an associative reduction</span>
<span class="sd">        operator: by forcing this restriction, Dampr is able to perform a partial </span>
<span class="sd">        reduction of the collection during the mapping sequence which can dramatically</span>
<span class="sd">        speed up the performace of the reduce stage.</span>

<span class="sd">        When possible, use a_group_by over the more general group_by.</span>

<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).reduce(lambda x, y: x+y).read()</span>
<span class="sd">            [(0, 6), (1, 9)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_a_group_by</span><span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">key</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">vf</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># We don&#39;t checkpoint here!</span>
        <span class="n">pm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_a_group_by</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ARReduce</span><span class="p">(</span><span class="n">pm</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fold_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">binop</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shortcut for a_group_by(key, value).reduce(binop)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_group_by</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">binop</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts the results by a given key function.</span>
<span class="sd">        </span>
<span class="sd">            Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 1).sort_by(lambda x: -x).read()</span>
<span class="sd">            [5, 3, 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_sort_by</span><span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">key</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">value</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_sort_by</span><span class="p">)</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Joins two independent computations, returning a Joining class.</span>

<span class="sd">        This is a powerful and expensive operation which can merge two Dampr </span>
<span class="sd">        collections together.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PBase</span><span class="p">)</span>
        <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PMap</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">pmer</span> <span class="o">=</span> <span class="n">Dampr</span><span class="p">(</span><span class="n">me</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">PJoin</span><span class="p">(</span><span class="n">me</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Counts each item X in the collection by its key </span>
<span class="sd">        function.</span>

<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).count(lambda x: x % 2).read()</span>
<span class="sd">            [(0, 2), (1, 3)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_group_by</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span> \
                <span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the mean of X, grouped by its key function and optionally</span>
<span class="sd">        mapped by a value function:</span>

<span class="sd">            &gt;&gt;&gt; ages = [(&quot;Andrew&quot;, 33), (&quot;Alice&quot;, 42), (&quot;Andrew&quot;, 12), (&quot;Bob&quot;, 51)]</span>
<span class="sd">            &gt;&gt;&gt; Dampr.memory(ages).mean(lambda x: x[0], lambda v: v[1]).read()</span>
<span class="sd">            [(&#39;Alice&#39;, 42.0), (&#39;Andrew&#39;, 22.5), (&#39;Bob&#39;, 51.0)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_mean_binop</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">_average</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_group_by</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span> \
                <span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">_mean_binop</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span> \
                <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">_average</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="nb">exit</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inspect is a debug function which prints each item X that flows through</span>
<span class="sd">        it.  It&#39;s valueable in inspecting intermediate results of a pipeline </span>
<span class="sd">        without changing the values internally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_inspect</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{}: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>

        <span class="n">ins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_inspect</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">exit</span><span class="p">:</span>
            <span class="n">ins</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ins</span>

    <span class="k">def</span> <span class="nf">cached</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The cached function runs a graph and stores it in memory.  This is </span>
<span class="sd">        useful for small datasets to gain extra performance in subsequent </span>
<span class="sd">        computations.</span>

<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5,6]).mean(lambda x: x % 2).cached().read()</span>
<span class="sd">            [(0, 4.0), (1, 3.0)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Run the pipeline, load it into memory, and create a new graph</span>
        <span class="n">options</span><span class="p">[</span><span class="s1">&#39;memory&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Since writes each X in a collection to a given path.  The path will</span>
<span class="sd">        create a directory and write each map or reduce partition into the</span>
<span class="sd">        directory as partitions.  Sink assumes each X in the collection is </span>
<span class="sd">        already a unicode string.</span>

<span class="sd">            &gt;&gt;&gt; Dampr.memory([&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]).sink(&quot;/tmp/foo&quot;).run()</span>
<span class="sd">            &gt;&gt;&gt; open(&quot;/tmp/foo/0&quot;).read()</span>
<span class="sd">            &gt;&gt;&gt; open(&quot;/tmp/foo/1&quot;).read()</span>
<span class="sd">            &gt;&gt;&gt; open(&quot;/tmp/foo/2&quot;).read()</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">aggs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Map</span><span class="p">(</span><span class="n">_identity</span><span class="p">)]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">agg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">agg</span><span class="p">[:]</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39; -&gt; &#39;</span> <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">aggs</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Stage {}: </span><span class="si">%s</span><span class="s1"> =&gt; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_sink</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">],</span> 
                <span class="n">Map</span><span class="p">(</span><span class="n">fuse</span><span class="p">(</span><span class="n">aggs</span><span class="p">)),</span> 
                <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">options</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span> 

    <span class="k">def</span> <span class="nf">sink_tsv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A convenience function which takes a tuple or list, creates a simple</span>
<span class="sd">        tab-delimited output, and sinks it to the provided path:</span>

<span class="sd">            &gt;&gt;&gt; Dampr.memory([(&quot;Hank Aaron&quot;, 755)]).sink_tsv(&quot;/tmp/foo&quot;).run()</span>
<span class="sd">            &gt;&gt;&gt; open(&quot;/tmp/foo/0&quot;).read()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">unicode</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">sink</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sink_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A convenience function which takes a simple python object and serializes</span>
<span class="sd">        it to a line-delimited json to the given path:</span>

<span class="sd">            &gt;&gt;&gt; Dampr.memory([{&quot;name&quot;: &quot;Hank Aaron&quot;, &quot;home runs&quot;: 755}]).sink_json(&quot;/tmp/foo&quot;).run()</span>
<span class="sd">            &gt;&gt;&gt; open(&quot;/tmp/foo/0&quot;).read()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">)</span><span class="o">.</span><span class="n">sink</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cross_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">cross</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produces the cross product between two datasets during the map stage.</span>
<span class="sd">        This is an incredibly expensive operation when done against two large</span>
<span class="sd">        datasets.  </span>

<span class="sd">        When it is known that the right dataset is small, setting `memory` to `True`</span>
<span class="sd">        will cache the right dataset in memory, speeding up the computation significantly.</span>

<span class="sd">        Two items, Xi and Yi, are joined with the cross function.</span>

<span class="sd">            &gt;&gt;&gt; left = Dampr.memory([1,2,3,4,5])</span>
<span class="sd">            &gt;&gt;&gt; right = Dampr.memory([&#39;foo&#39;, &#39;bar&#39;])</span>
<span class="sd">            &gt;&gt;&gt; left.cross_right(right, lambda x, y: (x, y)).read()</span>
<span class="sd">            [(1, &#39;foo&#39;), (1, &#39;bar&#39;), (2, &#39;foo&#39;), (2, &#39;bar&#39;), (3, &#39;foo&#39;), (3, &#39;bar&#39;), (4, &#39;foo&#39;), (4, &#39;bar&#39;), (5, &#39;foo&#39;), (5, &#39;bar&#39;)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PMap</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">cross_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">:</span> <span class="n">cross</span><span class="p">(</span><span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">),</span> <span class="n">memory</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cross_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">cross</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produces the cross product between two datasets during the map stage.</span>
<span class="sd">        This is an incredibly expensive operation when done against two large</span>
<span class="sd">        datasets.  </span>

<span class="sd">        When it is known that the left dataset is small, setting `memory` to `True`</span>
<span class="sd">        will cache the right dataset in memory, speeding up the computation significantly.</span>

<span class="sd">        Two items, Xi and Yi, are joined with the cross function.</span>

<span class="sd">            &gt;&gt;&gt; left = Dampr.memory([1,2,3,4,5])</span>
<span class="sd">            &gt;&gt;&gt; right = Dampr.memory([&#39;foo&#39;, &#39;bar&#39;])</span>
<span class="sd">            &gt;&gt;&gt; left.cross_left(right, lambda x, y: (x, y)).read()</span>
<span class="sd">            [(1, &#39;foo&#39;), (2, &#39;foo&#39;), (3, &#39;foo&#39;), (4, &#39;foo&#39;), (5, &#39;foo&#39;), (1, &#39;bar&#39;), (2, &#39;bar&#39;), (3, &#39;bar&#39;), (4, &#39;bar&#39;), (5, &#39;bar&#39;)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_cross</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">k1</span><span class="p">,</span> <span class="n">cross</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>

        <span class="n">pmer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
        <span class="n">pmer</span> <span class="o">=</span> <span class="n">Dampr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span><span class="p">))</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Stage {}: (</span><span class="si">%s</span><span class="s1"> X </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="n">pmer</span><span class="o">.</span><span class="n">_add_mapper</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">],</span> 
                <span class="n">MapCrossJoin</span><span class="p">(</span><span class="n">_cross</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">memory</span><span class="p">),</span> 
                <span class="n">combiner</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span> 
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#dampr.PMap">PMap</a></li>
          <li>dampr.dampr.PBase</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="dampr.PMap.agg" class="name">var <span class="ident">agg</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="dampr.PMap.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, source, pmer, agg=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.__init__', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">,</span> <span class="n">agg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">PMap</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">agg</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">agg</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">agg</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.a_group_by">
    <p>def <span class="ident">a_group_by</span>(</p><p>self, key, vf=&lt;function &lt;lambda&gt; at 0x7fb39f6c1938&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Groups a collection of X by a key function and optionally mapping X to Y
using <code>vf</code>.  It differs from <code>group_by</code> by requiring an associative reduction
operator: by forcing this restriction, Dampr is able to perform a partial 
reduction of the collection during the mapping sequence which can dramatically
speed up the performace of the reduce stage.</p>
<p>When possible, use a_group_by over the more general group_by.</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).reduce(lambda x, y: x+y).read()
[(0, 6), (1, 9)]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.a_group_by', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.a_group_by" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">a_group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">vf</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Groups a collection of X by a key function and optionally mapping X to Y</span>
<span class="sd">    using `vf`.  It differs from `group_by` by requiring an associative reduction</span>
<span class="sd">    operator: by forcing this restriction, Dampr is able to perform a partial </span>
<span class="sd">    reduction of the collection during the mapping sequence which can dramatically</span>
<span class="sd">    speed up the performace of the reduce stage.</span>
<span class="sd">    When possible, use a_group_by over the more general group_by.</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).reduce(lambda x, y: x+y).read()</span>
<span class="sd">        [(0, 6), (1, 9)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_a_group_by</span><span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">key</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">vf</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="c1"># We don&#39;t checkpoint here!</span>
    <span class="n">pm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_a_group_by</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ARReduce</span><span class="p">(</span><span class="n">pm</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.cached">
    <p>def <span class="ident">cached</span>(</p><p>self, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>The cached function runs a graph and stores it in memory.  This is 
useful for small datasets to gain extra performance in subsequent 
computations.</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5,6]).mean(lambda x: x % 2).cached().read()
[(0, 4.0), (1, 3.0)]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.cached', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.cached" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">cached</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The cached function runs a graph and stores it in memory.  This is </span>
<span class="sd">    useful for small datasets to gain extra performance in subsequent </span>
<span class="sd">    computations.</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5,6]).mean(lambda x: x % 2).cached().read()</span>
<span class="sd">        [(0, 4.0), (1, 3.0)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Run the pipeline, load it into memory, and create a new graph</span>
    <span class="n">options</span><span class="p">[</span><span class="s1">&#39;memory&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.checkpoint">
    <p>def <span class="ident">checkpoint</span>(</p><p>self, force=False, combiner=None, options=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Checkpoint forces Dampr to fuse all cached maps and add it as a MR stage.</p>
<p>This is useful when sharing the results of a computation with multiple other graphs.</p>
<p>Without checkpoint(), Dampr would execute the shared graph multiple times rather than reuse
the results of the computation:</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; evens = Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 0).checkpoint()
&gt;&gt;&gt; summed = evens.group_by(lambda x: 1).sum()
&gt;&gt;&gt; multiplied = evens.group_by(lambda x: 1).reduce(lambda x, y: x * y)
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.checkpoint', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.checkpoint" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">combiner</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checkpoint forces Dampr to fuse all cached maps and add it as a MR stage.</span>
<span class="sd">    This is useful when sharing the results of a computation with multiple other graphs.</span>
<span class="sd">    </span>
<span class="sd">    Without checkpoint(), Dampr would execute the shared graph multiple times rather than reuse</span>
<span class="sd">    the results of the computation:</span>
<span class="sd">        &gt;&gt;&gt; evens = Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 0).checkpoint()</span>
<span class="sd">        &gt;&gt;&gt; summed = evens.group_by(lambda x: 1).sum()</span>
<span class="sd">        &gt;&gt;&gt; multiplied = evens.group_by(lambda x: 1).reduce(lambda x, y: x * y)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">agg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">force</span><span class="p">:</span>
        <span class="n">aggs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Map</span><span class="p">(</span><span class="n">_identity</span><span class="p">)]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">agg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">agg</span><span class="p">[:]</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39; -&gt; &#39;</span> <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">aggs</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Stage {}: </span><span class="si">%s</span><span class="s1"> =&gt; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_mapper</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">],</span> 
                <span class="n">Map</span><span class="p">(</span><span class="n">fuse</span><span class="p">(</span><span class="n">aggs</span><span class="p">)),</span> 
                <span class="n">combiner</span><span class="o">=</span><span class="n">combiner</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span> 
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.count">
    <p>def <span class="ident">count</span>(</p><p>self, key=&lt;function &lt;lambda&gt; at 0x7fb39f6c1c08&gt;, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Counts each item X in the collection by its key 
function.</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).count(lambda x: x % 2).read()
[(0, 2), (1, 3)]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.count', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.count" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Counts each item X in the collection by its key </span>
<span class="sd">    function.</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).count(lambda x: x % 2).read()</span>
<span class="sd">        [(0, 2), (1, 3)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_group_by</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span> \
            <span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.cross_left">
    <p>def <span class="ident">cross_left</span>(</p><p>self, other, cross, memory=False, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Produces the cross product between two datasets during the map stage.
This is an incredibly expensive operation when done against two large
datasets.  </p>
<p>When it is known that the left dataset is small, setting <code>memory</code> to <code>True</code>
will cache the right dataset in memory, speeding up the computation significantly.</p>
<p>Two items, Xi and Yi, are joined with the cross function.</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; left = Dampr.memory([1,2,3,4,5])
&gt;&gt;&gt; right = Dampr.memory([&#39;foo&#39;, &#39;bar&#39;])
&gt;&gt;&gt; left.cross_left(right, lambda x, y: (x, y)).read()
[(1, &#39;foo&#39;), (2, &#39;foo&#39;), (3, &#39;foo&#39;), (4, &#39;foo&#39;), (5, &#39;foo&#39;), (1, &#39;bar&#39;), (2, &#39;bar&#39;), (3, &#39;bar&#39;), (4, &#39;bar&#39;), (5, &#39;bar&#39;)]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.cross_left', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.cross_left" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">cross_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">cross</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Produces the cross product between two datasets during the map stage.</span>
<span class="sd">    This is an incredibly expensive operation when done against two large</span>
<span class="sd">    datasets.  </span>
<span class="sd">    When it is known that the left dataset is small, setting `memory` to `True`</span>
<span class="sd">    will cache the right dataset in memory, speeding up the computation significantly.</span>
<span class="sd">    Two items, Xi and Yi, are joined with the cross function.</span>
<span class="sd">        &gt;&gt;&gt; left = Dampr.memory([1,2,3,4,5])</span>
<span class="sd">        &gt;&gt;&gt; right = Dampr.memory([&#39;foo&#39;, &#39;bar&#39;])</span>
<span class="sd">        &gt;&gt;&gt; left.cross_left(right, lambda x, y: (x, y)).read()</span>
<span class="sd">        [(1, &#39;foo&#39;), (2, &#39;foo&#39;), (3, &#39;foo&#39;), (4, &#39;foo&#39;), (5, &#39;foo&#39;), (1, &#39;bar&#39;), (2, &#39;bar&#39;), (3, &#39;bar&#39;), (4, &#39;bar&#39;), (5, &#39;bar&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_cross</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">k1</span><span class="p">,</span> <span class="n">cross</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
    <span class="n">pmer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
    <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
    <span class="n">pmer</span> <span class="o">=</span> <span class="n">Dampr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span><span class="p">))</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Stage {}: (</span><span class="si">%s</span><span class="s1"> X </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="n">pmer</span><span class="o">.</span><span class="n">_add_mapper</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">],</span> 
            <span class="n">MapCrossJoin</span><span class="p">(</span><span class="n">_cross</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">memory</span><span class="p">),</span> 
            <span class="n">combiner</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span> 
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.cross_right">
    <p>def <span class="ident">cross_right</span>(</p><p>self, other, cross, memory=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Produces the cross product between two datasets during the map stage.
This is an incredibly expensive operation when done against two large
datasets.  </p>
<p>When it is known that the right dataset is small, setting <code>memory</code> to <code>True</code>
will cache the right dataset in memory, speeding up the computation significantly.</p>
<p>Two items, Xi and Yi, are joined with the cross function.</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; left = Dampr.memory([1,2,3,4,5])
&gt;&gt;&gt; right = Dampr.memory([&#39;foo&#39;, &#39;bar&#39;])
&gt;&gt;&gt; left.cross_right(right, lambda x, y: (x, y)).read()
[(1, &#39;foo&#39;), (1, &#39;bar&#39;), (2, &#39;foo&#39;), (2, &#39;bar&#39;), (3, &#39;foo&#39;), (3, &#39;bar&#39;), (4, &#39;foo&#39;), (4, &#39;bar&#39;), (5, &#39;foo&#39;), (5, &#39;bar&#39;)]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.cross_right', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.cross_right" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">cross_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">cross</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Produces the cross product between two datasets during the map stage.</span>
<span class="sd">    This is an incredibly expensive operation when done against two large</span>
<span class="sd">    datasets.  </span>
<span class="sd">    When it is known that the right dataset is small, setting `memory` to `True`</span>
<span class="sd">    will cache the right dataset in memory, speeding up the computation significantly.</span>
<span class="sd">    Two items, Xi and Yi, are joined with the cross function.</span>
<span class="sd">        &gt;&gt;&gt; left = Dampr.memory([1,2,3,4,5])</span>
<span class="sd">        &gt;&gt;&gt; right = Dampr.memory([&#39;foo&#39;, &#39;bar&#39;])</span>
<span class="sd">        &gt;&gt;&gt; left.cross_right(right, lambda x, y: (x, y)).read()</span>
<span class="sd">        [(1, &#39;foo&#39;), (1, &#39;bar&#39;), (2, &#39;foo&#39;), (2, &#39;bar&#39;), (3, &#39;foo&#39;), (3, &#39;bar&#39;), (4, &#39;foo&#39;), (4, &#39;bar&#39;), (5, &#39;foo&#39;), (5, &#39;bar&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PMap</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">cross_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">:</span> <span class="n">cross</span><span class="p">(</span><span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">),</span> <span class="n">memory</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.custom_mapper">
    <p>def <span class="ident">custom_mapper</span>(</p><p>self, mapper, name=None, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Custom Mapper provides a low-level interface to the underlying map function.
Users can provide any instance which adhere's to the Mapper interface, allowing
for powerful or specific implementations.</p>
<p>This is typically used very rarely and has some caveats such as not fusing
with other Mappers.  Similarly, the implementer needs to understand more of the
nuances associated with keys.</p>
<div class="codehilite"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">dampr.base</span> <span class="kn">import</span> <span class="n">Map</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Dampr</span><span class="o">.</span><span class="n">memory</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">custom_mapper</span><span class="p">(</span><span class="n">Map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)]))</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.custom_mapper', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.custom_mapper" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">custom_mapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Custom Mapper provides a low-level interface to the underlying map function.</span>
<span class="sd">    Users can provide any instance which adhere&#39;s to the Mapper interface, allowing</span>
<span class="sd">    for powerful or specific implementations.</span>
<span class="sd">    This is typically used very rarely and has some caveats such as not fusing</span>
<span class="sd">    with other Mappers.  Similarly, the implementer needs to understand more of the</span>
<span class="sd">    nuances associated with keys.</span>
<span class="sd">        &gt;&gt;&gt; from dampr.base import Map</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).custom_mapper(Map(lambda k, x: [(k, x+1)])).read()</span>
<span class="sd">        [2, 3, 4, 5, 6]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">Mapper</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
    <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_mapper</span><span class="p">([</span><span class="n">me</span><span class="o">.</span><span class="n">source</span><span class="p">],</span> 
            <span class="n">mapper</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.custom_reducer">
    <p>def <span class="ident">custom_reducer</span>(</p><p>self, reducer, name=None, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Allows the user to provide any Reducer which adheres to the Reducer interface.
This is a very powerful, low-level interface which should be avoided when possible
as it's easy to write bugs.</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).custom_reducer(Reduce(lambda k, x: [(k, sum(x))])).read()
[[(0, 1)], [(1, 2)], [(2, 3)], [(3, 4)], [(4, 5)]]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.custom_reducer', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.custom_reducer" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">custom_reducer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reducer</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Allows the user to provide any Reducer which adheres to the Reducer interface.</span>
<span class="sd">    This is a very powerful, low-level interface which should be avoided when possible</span>
<span class="sd">    as it&#39;s easy to write bugs.</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).custom_reducer(Reduce(lambda k, x: [(k, sum(x))])).read()</span>
<span class="sd">        [[(0, 1)], [(1, 2)], [(2, 3)], [(3, 4)], [(4, 5)]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="n">Reducer</span><span class="p">)</span>
    <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">reducer</span><span class="p">)</span>
    <span class="n">new_source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="n">me</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_reducer</span><span class="p">([</span><span class="n">me</span><span class="o">.</span><span class="n">source</span><span class="p">],</span> 
            <span class="n">reducer</span><span class="p">,</span> 
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">new_source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.filter">
    <p>def <span class="ident">filter</span>(</p><p>self, f)</p>
    </div>
    

    
  
    <div class="desc"><p>Filters items from a collection based on a predicate f.
A predicate return True keeps the item.</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 1).read()
[1, 3, 5]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.filter', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.filter" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filters items from a collection based on a predicate f.</span>
<span class="sd">    A predicate return True keeps the item.</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 1).read()</span>
<span class="sd">        [1, 3, 5]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_filter</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_filter</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.flat_map">
    <p>def <span class="ident">flat_map</span>(</p><p>self, f)</p>
    </div>
    

    
  
    <div class="desc"><p>Maps elements in the underlying collection using function f, 
flattening the results</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).flat_map(range).read()
[0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.flat_map', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.flat_map" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">flat_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps elements in the underlying collection using function f, </span>
<span class="sd">    flattening the results</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).flat_map(range).read()</span>
<span class="sd">        [0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_flat_map</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">vi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">vi</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_flat_map</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.fold_by">
    <p>def <span class="ident">fold_by</span>(</p><p>self, key, binop, value=&lt;function &lt;lambda&gt; at 0x7fb39f6c1a28&gt;, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Shortcut for a_group_by(key, value).reduce(binop)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.fold_by', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.fold_by" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">fold_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">binop</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shortcut for a_group_by(key, value).reduce(binop)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_group_by</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">binop</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.group_by">
    <p>def <span class="ident">group_by</span>(</p><p>self, key, vf=&lt;function &lt;lambda&gt; at 0x7fb39f6c1848&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Groups a collections of X by a key function, optionally mapping X to Y 
using <code>vf</code>.  Returns a Reducer object for different types of aggregations</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).group_by(lambda x: x % 2).reduce(lambda k, it: sum(it)).read()
[(0, 6), (1, 9)]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.group_by', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.group_by" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">vf</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Groups a collections of X by a key function, optionally mapping X to Y </span>
<span class="sd">    using `vf`.  Returns a Reducer object for different types of aggregations</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).group_by(lambda x: x % 2).reduce(lambda k, it: sum(it)).read()</span>
<span class="sd">        [(0, 6), (1, 9)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_group_by</span><span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">key</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">vf</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="n">pm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_group_by</span><span class="p">)</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">PReduce</span><span class="p">(</span><span class="n">pm</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">pm</span><span class="o">.</span><span class="n">pmer</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.inspect">
    <p>def <span class="ident">inspect</span>(</p><p>self, prefix=&#39;&#39;, exit=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Inspect is a debug function which prints each item X that flows through
it.  It's valueable in inspecting intermediate results of a pipeline 
without changing the values internally.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.inspect', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.inspect" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="nb">exit</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inspect is a debug function which prints each item X that flows through</span>
<span class="sd">    it.  It&#39;s valueable in inspecting intermediate results of a pipeline </span>
<span class="sd">    without changing the values internally.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_inspect</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{}: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
    <span class="n">ins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_inspect</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">exit</span><span class="p">:</span>
        <span class="n">ins</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ins</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.join">
    <p>def <span class="ident">join</span>(</p><p>self, other)</p>
    </div>
    

    
  
    <div class="desc"><p>Joins two independent computations, returning a Joining class.</p>
<p>This is a powerful and expensive operation which can merge two Dampr 
collections together.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.join', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.join" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Joins two independent computations, returning a Joining class.</span>
<span class="sd">    This is a powerful and expensive operation which can merge two Dampr </span>
<span class="sd">    collections together.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PBase</span><span class="p">)</span>
    <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PMap</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">pmer</span> <span class="o">=</span> <span class="n">Dampr</span><span class="p">(</span><span class="n">me</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">PJoin</span><span class="p">(</span><span class="n">me</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.map">
    <p>def <span class="ident">map</span>(</p><p>self, f)</p>
    </div>
    

    
  
    <div class="desc"><p>Maps elements in the underlying collection using function 
<code>f</code>:</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).map(lambda x: x + 1).read()
[2, 3, 4, 5, 6]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.map', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.map" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps elements in the underlying collection using function </span>
<span class="sd">    `f`:</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).map(lambda x: x + 1).read()</span>
<span class="sd">        [2, 3, 4, 5, 6]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_map</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_map</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.mean">
    <p>def <span class="ident">mean</span>(</p><p>self, key=&lt;function &lt;lambda&gt; at 0x7fb39f6c1cf8&gt;, value=&lt;function &lt;lambda&gt; at 0x7fb39f6c1d70&gt;, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Finds the mean of X, grouped by its key function and optionally
mapped by a value function:</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; ages = [(&quot;Andrew&quot;, 33), (&quot;Alice&quot;, 42), (&quot;Andrew&quot;, 12), (&quot;Bob&quot;, 51)]
&gt;&gt;&gt; Dampr.memory(ages).mean(lambda x: x[0], lambda v: v[1]).read()
[(&#39;Alice&#39;, 42.0), (&#39;Andrew&#39;, 22.5), (&#39;Bob&#39;, 51.0)]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.mean', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.mean" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the mean of X, grouped by its key function and optionally</span>
<span class="sd">    mapped by a value function:</span>
<span class="sd">        &gt;&gt;&gt; ages = [(&quot;Andrew&quot;, 33), (&quot;Alice&quot;, 42), (&quot;Andrew&quot;, 12), (&quot;Bob&quot;, 51)]</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory(ages).mean(lambda x: x[0], lambda v: v[1]).read()</span>
<span class="sd">        [(&#39;Alice&#39;, 42.0), (&#39;Andrew&#39;, 22.5), (&#39;Bob&#39;, 51.0)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_mean_binop</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">_average</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_group_by</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span> \
            <span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">_mean_binop</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span> \
            <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">_average</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.partition_map">
    <p>def <span class="ident">partition_map</span>(</p><p>self, f, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Provides a medium-level interface for writing custom functionality for mapping 
a partition.  This can be used for creating custom logic in mappers for the sake
of performance or additional functionality.</p>
<p><code>f</code> is a function that takes in an iterator of items in the partition and yields 
out group keys and new values.</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; def plus_one(items):
...   for num in items:
...     yield num, num + 1
...
&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).partition_map(plus_one).read()
[2, 3, 4, 5, 6]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.partition_map', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.partition_map" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">partition_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provides a medium-level interface for writing custom functionality for mapping </span>
<span class="sd">    a partition.  This can be used for creating custom logic in mappers for the sake</span>
<span class="sd">    of performance or additional functionality.</span>
<span class="sd">    `f` is a function that takes in an iterator of items in the partition and yields </span>
<span class="sd">    out group keys and new values.</span>
<span class="sd">        &gt;&gt;&gt; def plus_one(items):</span>
<span class="sd">        ...   for num in items:</span>
<span class="sd">        ...     yield num, num + 1</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).partition_map(plus_one).read()</span>
<span class="sd">        [2, 3, 4, 5, 6]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_mapper</span><span class="p">(</span><span class="n">StreamMapper</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.partition_reduce">
    <p>def <span class="ident">partition_reduce</span>(</p><p>self, f)</p>
    </div>
    

    
  
    <div class="desc"><p><code>partition_reduce</code> is a medium-level function that allows for more complex logic
during reductions.  It can be useful in certain cases where reductions over sets
of reduced values is convenient, such as returning only the top K items in a dataset</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; def largest_number(it):
...   largest = float(&#39;-inf&#39;)
...   for group_key, its in it:
...     for value in its:
...       largest = max(largest, value)
...   yield &quot;Largest&quot;, largest
...
&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).partition_reduce(largest_number).read(n_partitions=1)
[(&#39;Largest&#39;, 5)]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.partition_reduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.partition_reduce" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">partition_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `partition_reduce` is a medium-level function that allows for more complex logic</span>
<span class="sd">    during reductions.  It can be useful in certain cases where reductions over sets</span>
<span class="sd">    of reduced values is convenient, such as returning only the top K items in a dataset</span>
<span class="sd">        &gt;&gt;&gt; def largest_number(it):</span>
<span class="sd">        ...   largest = float(&#39;-inf&#39;)</span>
<span class="sd">        ...   for group_key, its in it:</span>
<span class="sd">        ...     for value in its:</span>
<span class="sd">        ...       largest = max(largest, value)</span>
<span class="sd">        ...   yield &quot;Largest&quot;, largest</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).partition_reduce(largest_number).read(n_partitions=1)</span>
<span class="sd">        [(&#39;Largest&#39;, 5)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_reducer</span><span class="p">(</span><span class="n">StreamReducer</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.read">
    <p>def <span class="ident">read</span>(</p><p>self, k=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Shorthand for run() followed by a read()</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.read', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.read" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shorthand for run() followed by a read()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.run">
    <p>def <span class="ident">run</span>(</p><p>self, name=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Run the defined graph.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.run', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.run" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run the defined graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">agg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">PMap</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.sample">
    <p>def <span class="ident">sample</span>(</p><p>self, prob)</p>
    </div>
    

    
  
    <div class="desc"><p>Samples data with a given probability.  For example:</p>
<p><code>graph.sample(0.1)</code> will uniformly sample 10% of the data in the collection.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.sample', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.sample" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Samples data with a given probability.  For example:</span>
<span class="sd">    </span>
<span class="sd">    `graph.sample(0.1)` will uniformly sample 10% of the data in the collection.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">prob</span> <span class="o">&lt;=</span> <span class="mf">1.0</span>
    <span class="k">def</span> <span class="nf">_sample</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">get_rand</span><span class="p">()</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">prob</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_sample</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.sink">
    <p>def <span class="ident">sink</span>(</p><p>self, path)</p>
    </div>
    

    
  
    <div class="desc"><p>Since writes each X in a collection to a given path.  The path will
create a directory and write each map or reduce partition into the
directory as partitions.  Sink assumes each X in the collection is 
already a unicode string.</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; Dampr.memory([&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]).sink(&quot;/tmp/foo&quot;).run()
&gt;&gt;&gt; open(&quot;/tmp/foo/0&quot;).read()
&gt;&gt;&gt; open(&quot;/tmp/foo/1&quot;).read()
&gt;&gt;&gt; open(&quot;/tmp/foo/2&quot;).read()
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.sink', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.sink" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">sink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Since writes each X in a collection to a given path.  The path will</span>
<span class="sd">    create a directory and write each map or reduce partition into the</span>
<span class="sd">    directory as partitions.  Sink assumes each X in the collection is </span>
<span class="sd">    already a unicode string.</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]).sink(&quot;/tmp/foo&quot;).run()</span>
<span class="sd">        &gt;&gt;&gt; open(&quot;/tmp/foo/0&quot;).read()</span>
<span class="sd">        &gt;&gt;&gt; open(&quot;/tmp/foo/1&quot;).read()</span>
<span class="sd">        &gt;&gt;&gt; open(&quot;/tmp/foo/2&quot;).read()</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">aggs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Map</span><span class="p">(</span><span class="n">_identity</span><span class="p">)]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">agg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">agg</span><span class="p">[:]</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39; -&gt; &#39;</span> <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">aggs</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Stage {}: </span><span class="si">%s</span><span class="s1"> =&gt; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_sink</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">],</span> 
            <span class="n">Map</span><span class="p">(</span><span class="n">fuse</span><span class="p">(</span><span class="n">aggs</span><span class="p">)),</span> 
            <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span> 
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.sink_json">
    <p>def <span class="ident">sink_json</span>(</p><p>self, path)</p>
    </div>
    

    
  
    <div class="desc"><p>A convenience function which takes a simple python object and serializes
it to a line-delimited json to the given path:</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; Dampr.memory([{&quot;name&quot;: &quot;Hank Aaron&quot;, &quot;home runs&quot;: 755}]).sink_json(&quot;/tmp/foo&quot;).run()
&gt;&gt;&gt; open(&quot;/tmp/foo/0&quot;).read()
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.sink_json', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.sink_json" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">sink_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A convenience function which takes a simple python object and serializes</span>
<span class="sd">    it to a line-delimited json to the given path:</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([{&quot;name&quot;: &quot;Hank Aaron&quot;, &quot;home runs&quot;: 755}]).sink_json(&quot;/tmp/foo&quot;).run()</span>
<span class="sd">        &gt;&gt;&gt; open(&quot;/tmp/foo/0&quot;).read()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">)</span><span class="o">.</span><span class="n">sink</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.sink_tsv">
    <p>def <span class="ident">sink_tsv</span>(</p><p>self, path)</p>
    </div>
    

    
  
    <div class="desc"><p>A convenience function which takes a tuple or list, creates a simple
tab-delimited output, and sinks it to the provided path:</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; Dampr.memory([(&quot;Hank Aaron&quot;, 755)]).sink_tsv(&quot;/tmp/foo&quot;).run()
&gt;&gt;&gt; open(&quot;/tmp/foo/0&quot;).read()
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.sink_tsv', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.sink_tsv" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">sink_tsv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A convenience function which takes a tuple or list, creates a simple</span>
<span class="sd">    tab-delimited output, and sinks it to the provided path:</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([(&quot;Hank Aaron&quot;, 755)]).sink_tsv(&quot;/tmp/foo&quot;).run()</span>
<span class="sd">        &gt;&gt;&gt; open(&quot;/tmp/foo/0&quot;).read()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">unicode</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">sink</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.sort_by">
    <p>def <span class="ident">sort_by</span>(</p><p>self, key, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Sorts the results by a given key function.</p>
<p>Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 1).sort_by(lambda x: -x).read()
[5, 3, 1]</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.sort_by', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.sort_by" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">sort_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sorts the results by a given key function.</span>
<span class="sd">    </span>
<span class="sd">        Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 1).sort_by(lambda x: -x).read()</span>
<span class="sd">        [5, 3, 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_sort_by</span><span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">key</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">value</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_map</span><span class="p">(</span><span class="n">_sort_by</span><span class="p">)</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="dampr.PReduce" class="name">class <span class="ident">PReduce</span></p>
      
  
    <div class="desc"><p>A more general reduce class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PReduce</span><span class="p">(</span><span class="n">PBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A more general reduce class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduces a grouped set of items by f, which takes two arguments: the group key</span>
<span class="sd">        and an iterator lazily yield all items in the group.</span>

<span class="sd">            &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).group_by(lambda x: x % 2).reduce(lambda k, it: sum(it)).read()</span>
<span class="sd">            [(0, 6), (1, 9)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_reducer</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">],</span> <span class="n">KeyedReduce</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">new_source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the unique set of items in the grouping.</span>

<span class="sd">            &gt;&gt;&gt; names = [(&quot;Andrew&quot;, 1), (&quot;Andrew&quot;, 1), (&quot;Andrew&quot;, 2), (&quot;Becky&quot;, 13)]</span>
<span class="sd">            &gt;&gt;&gt; Dampr.memory(names).group_by(lambda x: x[0], lambda x: x[1]).unique().read()</span>
<span class="sd">            [(&#39;Andrew&#39;, [1, 2]), (&#39;Becky&#39;, [13])]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_uniq</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">it</span><span class="p">):</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">agg</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
                <span class="n">fv</span> <span class="o">=</span> <span class="n">key</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">fv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fv</span><span class="p">)</span>
                    <span class="n">agg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">agg</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">_uniq</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a join between two datasets on a given key, returning a PJoin object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PBase</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PMap</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">pmer</span> <span class="o">=</span> <span class="n">Dampr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">PJoin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">partition_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides medium-level functionality for partition reductions.  See </span>
<span class="sd">        PMap.partition_reduce for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reducer</span> <span class="o">=</span> <span class="n">StreamReducer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">reducer</span><span class="p">)</span>
        <span class="n">new_source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="n">me</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_reducer</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pm</span><span class="o">.</span><span class="n">source</span><span class="p">],</span> 
                <span class="n">reducer</span><span class="p">,</span> 
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">new_source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#dampr.PReduce">PReduce</a></li>
          <li>dampr.dampr.PBase</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="dampr.PReduce.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, source, pmer)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce.__init__', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">Source</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span> <span class="o">=</span> <span class="n">pmer</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PReduce.join">
    <p>def <span class="ident">join</span>(</p><p>self, other)</p>
    </div>
    

    
  
    <div class="desc"><p>Performs a join between two datasets on a given key, returning a PJoin object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce.join', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce.join" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs a join between two datasets on a given key, returning a PJoin object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PBase</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PMap</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">pmer</span> <span class="o">=</span> <span class="n">Dampr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">PJoin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PReduce.partition_reduce">
    <p>def <span class="ident">partition_reduce</span>(</p><p>self, f)</p>
    </div>
    

    
  
    <div class="desc"><p>Provides medium-level functionality for partition reductions.  See 
PMap.partition_reduce for more details.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce.partition_reduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce.partition_reduce" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">partition_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provides medium-level functionality for partition reductions.  See </span>
<span class="sd">    PMap.partition_reduce for more details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reducer</span> <span class="o">=</span> <span class="n">StreamReducer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">reducer</span><span class="p">)</span>
    <span class="n">new_source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="n">me</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_reducer</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pm</span><span class="o">.</span><span class="n">source</span><span class="p">],</span> 
            <span class="n">reducer</span><span class="p">,</span> 
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">new_source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PReduce.read">
    <p>def <span class="ident">read</span>(</p><p>self, k=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Shorthand for run() followed by a read()</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce.read', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce.read" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shorthand for run() followed by a read()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PReduce.reduce">
    <p>def <span class="ident">reduce</span>(</p><p>self, f)</p>
    </div>
    

    
  
    <div class="desc"><p>Reduces a grouped set of items by f, which takes two arguments: the group key
and an iterator lazily yield all items in the group.</p>
<div class="codehilite"><pre><span></span>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).group_by(lambda x: x % 2).reduce(lambda k, it: sum(it)).read()
[(0, 6), (1, 9)]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce.reduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce.reduce" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reduces a grouped set of items by f, which takes two arguments: the group key</span>
<span class="sd">    and an iterator lazily yield all items in the group.</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).group_by(lambda x: x % 2).reduce(lambda k, it: sum(it)).read()</span>
<span class="sd">        [(0, 6), (1, 9)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_source</span><span class="p">,</span> <span class="n">pmer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">_add_reducer</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">],</span> <span class="n">KeyedReduce</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">PMap</span><span class="p">(</span><span class="n">new_source</span><span class="p">,</span> <span class="n">pmer</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PReduce.run">
    <p>def <span class="ident">run</span>(</p><p>self, name=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Evaluates the composed Dampr graph with the provided name and subsequent options.
By default, uses /tmp as temporary storage.</p>
<p>Returns a ValueEmitter useful for shell access.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce.run', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce.run" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates the composed Dampr graph with the provided name and subsequent options.</span>
<span class="sd">    By default, uses /tmp as temporary storage.</span>
<span class="sd">    Returns a ValueEmitter useful for shell access.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;dampr/{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;run source: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">runner</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmer</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ValueEmitter</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PReduce.unique">
    <p>def <span class="ident">unique</span>(</p><p>self, key=&lt;function &lt;lambda&gt; at 0x7fb39f6c4488&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the unique set of items in the grouping.</p>
<blockquote>
<blockquote>
<blockquote>
<p>names = [("Andrew", 1), ("Andrew", 1), ("Andrew", 2), ("Becky", 13)]
Dampr.memory(names).group_by(lambda x: x[0], lambda x: x[1]).unique().read()
[('Andrew', [1, 2]), ('Becky', [13])]</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce.unique', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce.unique" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the unique set of items in the grouping.</span>
<span class="sd">        &gt;&gt;&gt; names = [(&quot;Andrew&quot;, 1), (&quot;Andrew&quot;, 1), (&quot;Andrew&quot;, 2), (&quot;Becky&quot;, 13)]</span>
<span class="sd">        &gt;&gt;&gt; Dampr.memory(names).group_by(lambda x: x[0], lambda x: x[1]).unique().read()</span>
<span class="sd">        [(&#39;Andrew&#39;, [1, 2]), (&#39;Becky&#39;, [13])]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_uniq</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">it</span><span class="p">):</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">agg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="n">fv</span> <span class="o">=</span> <span class="n">key</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fv</span><span class="p">)</span>
                <span class="n">agg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">agg</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">_uniq</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
