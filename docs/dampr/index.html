<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>dampr API documentation</title>
    <meta name="description" content="Dampr is a light-weight MapReduce library for single machine computation.  It supports a number of 
..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#dampr.ARReduce">ARReduce</a></span>
        
          
  <ul>
    <li class="mono"><a href="#dampr.ARReduce.__init__">__init__</a></li>
    <li class="mono"><a href="#dampr.ARReduce.first">first</a></li>
    <li class="mono"><a href="#dampr.ARReduce.reduce">reduce</a></li>
    <li class="mono"><a href="#dampr.ARReduce.sum">sum</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#dampr.BlockMapper">BlockMapper</a></span>
        
          
  <ul>
    <li class="mono"><a href="#dampr.BlockMapper.add">add</a></li>
    <li class="mono"><a href="#dampr.BlockMapper.finish">finish</a></li>
    <li class="mono"><a href="#dampr.BlockMapper.map">map</a></li>
    <li class="mono"><a href="#dampr.BlockMapper.start">start</a></li>
    <li class="mono"><a href="#dampr.BlockMapper.stream">stream</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#dampr.BlockReducer">BlockReducer</a></span>
        
          
  <ul>
    <li class="mono"><a href="#dampr.BlockReducer.add">add</a></li>
    <li class="mono"><a href="#dampr.BlockReducer.finish">finish</a></li>
    <li class="mono"><a href="#dampr.BlockReducer.group_datasets">group_datasets</a></li>
    <li class="mono"><a href="#dampr.BlockReducer.reduce">reduce</a></li>
    <li class="mono"><a href="#dampr.BlockReducer.start">start</a></li>
    <li class="mono"><a href="#dampr.BlockReducer.yield_groups">yield_groups</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#dampr.Dampr">Dampr</a></span>
        
          
  <ul>
    <li class="mono"><a href="#dampr.Dampr.__init__">__init__</a></li>
    <li class="mono"><a href="#dampr.Dampr.from_dataset">from_dataset</a></li>
    <li class="mono"><a href="#dampr.Dampr.json">json</a></li>
    <li class="mono"><a href="#dampr.Dampr.memory">memory</a></li>
    <li class="mono"><a href="#dampr.Dampr.read_input">read_input</a></li>
    <li class="mono"><a href="#dampr.Dampr.run">run</a></li>
    <li class="mono"><a href="#dampr.Dampr.text">text</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#dampr.PJoin">PJoin</a></span>
        
          
  <ul>
    <li class="mono"><a href="#dampr.PJoin.__init__">__init__</a></li>
    <li class="mono"><a href="#dampr.PJoin.left_reduce">left_reduce</a></li>
    <li class="mono"><a href="#dampr.PJoin.read">read</a></li>
    <li class="mono"><a href="#dampr.PJoin.reduce">reduce</a></li>
    <li class="mono"><a href="#dampr.PJoin.run">run</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#dampr.PMap">PMap</a></span>
        
          
  <ul>
    <li class="mono"><a href="#dampr.PMap.__init__">__init__</a></li>
    <li class="mono"><a href="#dampr.PMap.a_group_by">a_group_by</a></li>
    <li class="mono"><a href="#dampr.PMap.cached">cached</a></li>
    <li class="mono"><a href="#dampr.PMap.checkpoint">checkpoint</a></li>
    <li class="mono"><a href="#dampr.PMap.count">count</a></li>
    <li class="mono"><a href="#dampr.PMap.cross_left">cross_left</a></li>
    <li class="mono"><a href="#dampr.PMap.cross_right">cross_right</a></li>
    <li class="mono"><a href="#dampr.PMap.custom_mapper">custom_mapper</a></li>
    <li class="mono"><a href="#dampr.PMap.custom_reducer">custom_reducer</a></li>
    <li class="mono"><a href="#dampr.PMap.filter">filter</a></li>
    <li class="mono"><a href="#dampr.PMap.flat_map">flat_map</a></li>
    <li class="mono"><a href="#dampr.PMap.fold_by">fold_by</a></li>
    <li class="mono"><a href="#dampr.PMap.group_by">group_by</a></li>
    <li class="mono"><a href="#dampr.PMap.inspect">inspect</a></li>
    <li class="mono"><a href="#dampr.PMap.join">join</a></li>
    <li class="mono"><a href="#dampr.PMap.len">len</a></li>
    <li class="mono"><a href="#dampr.PMap.map">map</a></li>
    <li class="mono"><a href="#dampr.PMap.mean">mean</a></li>
    <li class="mono"><a href="#dampr.PMap.partition_map">partition_map</a></li>
    <li class="mono"><a href="#dampr.PMap.partition_reduce">partition_reduce</a></li>
    <li class="mono"><a href="#dampr.PMap.read">read</a></li>
    <li class="mono"><a href="#dampr.PMap.run">run</a></li>
    <li class="mono"><a href="#dampr.PMap.sample">sample</a></li>
    <li class="mono"><a href="#dampr.PMap.sink">sink</a></li>
    <li class="mono"><a href="#dampr.PMap.sink_json">sink_json</a></li>
    <li class="mono"><a href="#dampr.PMap.sink_tsv">sink_tsv</a></li>
    <li class="mono"><a href="#dampr.PMap.sort_by">sort_by</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#dampr.PReduce">PReduce</a></span>
        
          
  <ul>
    <li class="mono"><a href="#dampr.PReduce.__init__">__init__</a></li>
    <li class="mono"><a href="#dampr.PReduce.join">join</a></li>
    <li class="mono"><a href="#dampr.PReduce.partition_reduce">partition_reduce</a></li>
    <li class="mono"><a href="#dampr.PReduce.read">read</a></li>
    <li class="mono"><a href="#dampr.PReduce.reduce">reduce</a></li>
    <li class="mono"><a href="#dampr.PReduce.run">run</a></li>
    <li class="mono"><a href="#dampr.PReduce.unique">unique</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">dampr</span> module</h1>
  <p>Dampr is a light-weight MapReduce library for single machine computation.  It supports a number of 
useful features such as map and reduce side joins, associative reduces, 
aggregations, multiprocessing, and more.  It operates by default out-of-core, allowing
processing of 100s of gbs to tbs of data on a single machine.</p>
<p>While the underlying engine uses the MapReduce paradigm for processing, Dampr is 
best utilized via it's DSL which provides higher level functionality for complex workflows.</p>
<p>It loosely attempts to replicate interfaces such as Spark or Scalding for ease of pickup.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr', this);">Show source &equiv;</a></p>
  <div id="source-dampr" class="source">
    <pre><code>"""
Dampr is a light-weight MapReduce library for single machine computation.  It supports a number of 
useful features such as map and reduce side joins, associative reduces, 
aggregations, multiprocessing, and more.  It operates by default out-of-core, allowing
processing of 100s of gbs to tbs of data on a single machine.

While the underlying engine uses the MapReduce paradigm for processing, Dampr is 
best utilized via it's DSL which provides higher level functionality for complex workflows.

It loosely attempts to replicate interfaces such as Spark or Scalding for ease of pickup.
"""
import logging
from .dampr import Dampr, PMap, PReduce, PJoin, ARReduce
from .base import BlockMapper, BlockReducer
from .dataset import Dataset

__all__ = ["Dampr", "PMap", "PReduce", "PJoin", "ARReduce", 
        "BlockMapper", "BlockReducer"]


def setup_logging(debug=False):
    """
    Convenience function for enabling logging
    """
    loglevel = logging.DEBUG if debug else logging.INFO
    logging.basicConfig(level=loglevel,
                        format='%(asctime)s %(levelname)s %(message)s')
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="dampr.ARReduce" class="name">class <span class="ident">ARReduce</span></p>
      
  
    <div class="desc"><p>Associative Reducer operators.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.ARReduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.ARReduce" class="source">
    <pre><code>class ARReduce(object):
    """
    Associative Reducer operators.
    """
    def __init__(self, pmap):
        self.pmap = pmap

    def reduce(self, binop, reduce_buffer=1000, **options):
        """
        Reduces a grouped dataset by an associative binary operator.
        This will do a partial reduce in the map stage, completing the reduction
        in the reduce stage.  It is often substantially faster than the more
        general group_by.

        `reduce_buffer` is a constant which tells Dampr how much temporary storage
        to keep in memory on the map side reductions.  For example with `1000`, Dampr
        will keep 1000 unique keys in memory.  In the case where a new key would spill
        over the buffer size, Dampr will flush the buffer to disk and create a new
        buffer.  By increasing the `reduce_buffer`, you can increase efficiency while
        sacrificing memory.

            >>> Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: 1).reduce(lambda x, y: x + y).read()
            [(1, 15)]
        """
        def _reduce(key, vs):
            acc = next(vs)
            for v in vs:
                acc = binop(acc, v)

            return acc

        red = Reduce(_reduce)
        options.update({"binop": binop, "reduce_buffer": reduce_buffer})
        # We add the associative aggregator to the combiner during map
        pm = self.pmap.checkpoint(True, 
                combiner=PartialReduceCombiner(red), 
                options=options)
        return PReduce(pm.source, pm.pmer).reduce(_reduce)
    
    def first(self, **options):
        """
        Returns the first item found for a given key. 
            >>> Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).first().read()
            [(0, 2), (1, 1)]
        """
        return self.reduce(lambda x, _y: x, **options)

    def sum(self, **options):
        """
        Simple sum of values by key.

            >>> Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).sum().read()
            [(0, 6), (1, 9)]
        """
        return self.reduce(lambda x, y: x + y, **options)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#dampr.ARReduce">ARReduce</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="dampr.ARReduce.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, pmap)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.ARReduce.__init__', this);">Show source &equiv;</a></p>
  <div id="source-dampr.ARReduce.__init__" class="source">
    <pre><code>def __init__(self, pmap):
    self.pmap = pmap
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.ARReduce.first">
    <p>def <span class="ident">first</span>(</p><p>self, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the first item found for a given key. </p>
<blockquote>
<blockquote>
<blockquote>
<p>Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).first().read()
[(0, 2), (1, 1)]</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.ARReduce.first', this);">Show source &equiv;</a></p>
  <div id="source-dampr.ARReduce.first" class="source">
    <pre><code>def first(self, **options):
    """
    Returns the first item found for a given key. 
        >>> Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).first().read()
        [(0, 2), (1, 1)]
    """
    return self.reduce(lambda x, _y: x, **options)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.ARReduce.reduce">
    <p>def <span class="ident">reduce</span>(</p><p>self, binop, reduce_buffer=1000, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Reduces a grouped dataset by an associative binary operator.
This will do a partial reduce in the map stage, completing the reduction
in the reduce stage.  It is often substantially faster than the more
general group_by.</p>
<p><code>reduce_buffer</code> is a constant which tells Dampr how much temporary storage
to keep in memory on the map side reductions.  For example with <code>1000</code>, Dampr
will keep 1000 unique keys in memory.  In the case where a new key would spill
over the buffer size, Dampr will flush the buffer to disk and create a new
buffer.  By increasing the <code>reduce_buffer</code>, you can increase efficiency while
sacrificing memory.</p>
<pre><code>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: 1).reduce(lambda x, y: x + y).read()
[(1, 15)]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.ARReduce.reduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.ARReduce.reduce" class="source">
    <pre><code>def reduce(self, binop, reduce_buffer=1000, **options):
    """
    Reduces a grouped dataset by an associative binary operator.
    This will do a partial reduce in the map stage, completing the reduction
    in the reduce stage.  It is often substantially faster than the more
    general group_by.
    `reduce_buffer` is a constant which tells Dampr how much temporary storage
    to keep in memory on the map side reductions.  For example with `1000`, Dampr
    will keep 1000 unique keys in memory.  In the case where a new key would spill
    over the buffer size, Dampr will flush the buffer to disk and create a new
    buffer.  By increasing the `reduce_buffer`, you can increase efficiency while
    sacrificing memory.
        >>> Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: 1).reduce(lambda x, y: x + y).read()
        [(1, 15)]
    """
    def _reduce(key, vs):
        acc = next(vs)
        for v in vs:
            acc = binop(acc, v)
        return acc
    red = Reduce(_reduce)
    options.update({"binop": binop, "reduce_buffer": reduce_buffer})
    # We add the associative aggregator to the combiner during map
    pm = self.pmap.checkpoint(True, 
            combiner=PartialReduceCombiner(red), 
            options=options)
    return PReduce(pm.source, pm.pmer).reduce(_reduce)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.ARReduce.sum">
    <p>def <span class="ident">sum</span>(</p><p>self, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Simple sum of values by key.</p>
<blockquote>
<blockquote>
<blockquote>
<p>Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).sum().read()
[(0, 6), (1, 9)]</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.ARReduce.sum', this);">Show source &equiv;</a></p>
  <div id="source-dampr.ARReduce.sum" class="source">
    <pre><code>def sum(self, **options):
    """
    Simple sum of values by key.
        >>> Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).sum().read()
        [(0, 6), (1, 9)]
    """
    return self.reduce(lambda x, y: x + y, **options)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="dampr.ARReduce.pmap" class="name">var <span class="ident">pmap</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="dampr.BlockMapper" class="name">class <span class="ident">BlockMapper</span></p>
      
  
    <div class="desc"><p>Custom BlockMapper.  User's can specify how a Mapper instance can
consume a stream of key-values, allowing for custom logic.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockMapper', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockMapper" class="source">
    <pre><code>class BlockMapper(Mapper, Streamable):
    """
    Custom BlockMapper.  User's can specify how a Mapper instance can
    consume a stream of key-values, allowing for custom logic.
    """
    
    def start(self):
        """
        Sets up instance variables for when a Mapper begins consumption of 
        a Map Block.
        """
        pass

    def add(self, key, value):
        """
        Logic for how to handle new key-value pairs.  This function is required
        to return an iterator regardless of whether it yields data: this gives
        a more flexible definition.
        """
        raise NotImplementedError()

    def finish(self):
        """
        Mapping is finished.  In the case of aggregations, this should yield out
        all remaining key-values to consume.
        """
        return ()

    def map(self, *datasets):
        assert len(datasets) == 1
        return self.stream(datasets[0].read())

    def stream(self, kvs):
        self.start()
        for key, value in kvs:
            for out in self.add(key, value):
                yield out

        for out in self.finish():
            yield out
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#dampr.BlockMapper">BlockMapper</a></li>
          <li>dampr.base.Mapper</li>
          <li>dampr.base.Streamable</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="dampr.BlockMapper.add">
    <p>def <span class="ident">add</span>(</p><p>self, key, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Logic for how to handle new key-value pairs.  This function is required
to return an iterator regardless of whether it yields data: this gives
a more flexible definition.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockMapper.add', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockMapper.add" class="source">
    <pre><code>def add(self, key, value):
    """
    Logic for how to handle new key-value pairs.  This function is required
    to return an iterator regardless of whether it yields data: this gives
    a more flexible definition.
    """
    raise NotImplementedError()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockMapper.finish">
    <p>def <span class="ident">finish</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Mapping is finished.  In the case of aggregations, this should yield out
all remaining key-values to consume.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockMapper.finish', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockMapper.finish" class="source">
    <pre><code>def finish(self):
    """
    Mapping is finished.  In the case of aggregations, this should yield out
    all remaining key-values to consume.
    """
    return ()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockMapper.map">
    <p>def <span class="ident">map</span>(</p><p>self, *datasets)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockMapper.map', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockMapper.map" class="source">
    <pre><code>def map(self, *datasets):
    assert len(datasets) == 1
    return self.stream(datasets[0].read())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockMapper.start">
    <p>def <span class="ident">start</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets up instance variables for when a Mapper begins consumption of 
a Map Block.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockMapper.start', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockMapper.start" class="source">
    <pre><code>def start(self):
    """
    Sets up instance variables for when a Mapper begins consumption of 
    a Map Block.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockMapper.stream">
    <p>def <span class="ident">stream</span>(</p><p>self, kvs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockMapper.stream', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockMapper.stream" class="source">
    <pre><code>def stream(self, kvs):
    self.start()
    for key, value in kvs:
        for out in self.add(key, value):
            yield out
    for out in self.finish():
        yield out
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="dampr.BlockReducer" class="name">class <span class="ident">BlockReducer</span></p>
      
  
    <div class="desc"><p>Custom BlockReducer.  User's can specify how a Reducer instance can
consume a stream of key-valueiters, allowing for custom logic.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockReducer', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockReducer" class="source">
    <pre><code>class BlockReducer(Reducer):
    """
    Custom BlockReducer.  User's can specify how a Reducer instance can
    consume a stream of key-valueiters, allowing for custom logic.
    """
    def start(self):
        pass 

    def add(self, k, it):
        raise NotImplementedError()

    def finish(self):
        return ()

    def reduce(self, *datasets):
        assert len(datasets) == 1
        self.start()
        for k, vs in self.yield_groups(datasets[0]):
            for nk, nv in self.add(k, vs):
                yield nk, nv

        for nk, nv in self.finish():
            yield nk, nv
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#dampr.BlockReducer">BlockReducer</a></li>
          <li>dampr.base.Reducer</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="dampr.BlockReducer.add">
    <p>def <span class="ident">add</span>(</p><p>self, k, it)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockReducer.add', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockReducer.add" class="source">
    <pre><code>def add(self, k, it):
    raise NotImplementedError()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockReducer.finish">
    <p>def <span class="ident">finish</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockReducer.finish', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockReducer.finish" class="source">
    <pre><code>def finish(self):
    return ()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockReducer.group_datasets">
    <p>def <span class="ident">group_datasets</span>(</p><p>self, dataset)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockReducer.group_datasets', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockReducer.group_datasets" class="source">
    <pre><code>def group_datasets(self, dataset):
    if len(dataset) > 1:
        dataset = MergeDataset(dataset)
    elif len(dataset) == 1:
        dataset = dataset[0]
    else:
        dataset = EmptyDataset()
    
    return dataset
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockReducer.reduce">
    <p>def <span class="ident">reduce</span>(</p><p>self, *datasets)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockReducer.reduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockReducer.reduce" class="source">
    <pre><code>def reduce(self, *datasets):
    assert len(datasets) == 1
    self.start()
    for k, vs in self.yield_groups(datasets[0]):
        for nk, nv in self.add(k, vs):
            yield nk, nv
    for nk, nv in self.finish():
        yield nk, nv
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockReducer.start">
    <p>def <span class="ident">start</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockReducer.start', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockReducer.start" class="source">
    <pre><code>def start(self):
    pass 
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.BlockReducer.yield_groups">
    <p>def <span class="ident">yield_groups</span>(</p><p>self, dataset)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.BlockReducer.yield_groups', this);">Show source &equiv;</a></p>
  <div id="source-dampr.BlockReducer.yield_groups" class="source">
    <pre><code>def yield_groups(self, dataset):
    return self.group_datasets(dataset).grouped_read()
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="dampr.Dampr" class="name">class <span class="ident">Dampr</span></p>
      
  
    <div class="desc"><p>Entrypoint into the Dampr processing functions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.Dampr', this);">Show source &equiv;</a></p>
  <div id="source-dampr.Dampr" class="source">
    <pre><code>class Dampr(object):
    """
    Entrypoint into the Dampr processing functions.
    """
    def __init__(self, graph=None, runner=None):
        if graph is None:
            graph = Graph()

        self.graph = graph 
        if runner is None:
            runner = MTRunner

        self.runner = runner

    @classmethod
    def memory(cls, items, partitions=50):
        """
        Create an in-memory dataset from the provided items.  `partitions` define how
        many initial functions there will be.

            >>> Dampr.memory([1,2,3,4,5])
        """
        mi = MemoryInput(list(enumerate(items)), partitions)
        source, ng = Graph().add_input(mi)
        return PMap(source, Dampr(ng))

    @classmethod
    def read_input(self, *datasets):
        """
        Reads from the provided datasets.  When provided multiple datasets, it treats
        each as a separate partition.

        `read_input` can also take Chunker, which lazily returns a set of Datasets to
        operate over.

            >>> from dampr.inputs import MemoryInput
            >>> Dampr.read_input(MemoryInput(enumerate(range(5,10)), 2))
        """
        if len(datasets) == 1 and isinstance(datasets, Chunker):
            datasets = datasets[0]
        elif len(datasets) > 1:
            datasets = CatDataset(datasets)
        else:
            datasets = datasets[0]

        source, ng = Graph().add_input(datasets)
        return PMap(source, Dampr(ng))

    @classmethod
    def text(cls, fname, chunk_size=16*1024**2):
        """
        Reads a file or directory of files into Dampr.  Each record is assumed to 
        be newline delimited.  

        When fname is a directory, it will walk the directory, collecting all
        files within it as part of the collection.
        
        `chunk_size` describes how big each map portion will be.

        Returns a PMap object.

            >>> Dampr.text('/tmp', chunk_size=64*1024**2)
        """
        if os.path.isdir(fname):
            inp = DirectoryInput(fname, chunk_size)
        else:
            inp = TextInput(fname, chunk_size)

        source, ng = Graph().add_input(inp)
        return PMap(source, Dampr(ng))

    @classmethod
    def json(cls, *args, **kwargs):
        """
        Convenience function which reads newline-delimited json records.
        """
        return cls.text(*args, **kwargs).map(json.loads)

    @classmethod
    def from_dataset(cls, dataset):
        """
        Typically not used, this will read the raw outputs of a Dampr stage 
        as an input.
        """
        assert isinstance(dataset, Chunker)
        source, ng = Graph().add_input(dataset)
        return PMap(source, Dampr(ng))

    @classmethod
    def run(self, *pmers, **kwargs):
        """
        Runs a graph or set of graphs.

            >>> foo = Dampr.memory([1,2,3,4,5])
            >>> bar = Dampr.memory([6,7,8,9,10])
            >>> left, right = Dampr.run(foo, bar)
            >>> left.read()
            [1, 2, 3, 4, 5]
            >>> right.read()
            [6, 7, 8, 9, 10]
        """
        sources = []
        graph = None
        for i, pmer in enumerate(pmers):
            if isinstance(pmer, PMap):
                pmer = pmer.checkpoint()
            elif isinstance(pmer, PJoin):
                pmer = pmer.reduce(lambda l, r: (list(l), list(r)))
            
            if i == 0:
                graph = pmer.pmer.graph
            else:
                graph = pmer.pmer.graph.union(graph)

            sources.append(pmer.source)

        name = kwargs.pop('name', 'dampr/{}'.format(random.random()))
        ds = pmer.pmer.runner(name, graph, **kwargs).run(sources)
        return [ValueEmitter(d) for d in ds]

    def _add_mapper(self, *args, **kwargs): 
        output, ng = self.graph.add_mapper(*args, **kwargs)
        return output, Dampr(ng)

    def _add_reducer(self, *args, **kwargs): 
        output, ng = self.graph.add_reducer(*args, **kwargs)
        return output, Dampr(ng)

    def _add_sink(self, *args, **kwargs): 
        output, ng = self.graph.add_sink(*args, **kwargs)
        return output, Dampr(ng)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#dampr.Dampr">Dampr</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="dampr.Dampr.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, graph=None, runner=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.Dampr.__init__', this);">Show source &equiv;</a></p>
  <div id="source-dampr.Dampr.__init__" class="source">
    <pre><code>def __init__(self, graph=None, runner=None):
    if graph is None:
        graph = Graph()
    self.graph = graph 
    if runner is None:
        runner = MTRunner
    self.runner = runner
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="dampr.Dampr.graph" class="name">var <span class="ident">graph</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="dampr.Dampr.runner" class="name">var <span class="ident">runner</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="dampr.Dampr.from_dataset">
    <p>def <span class="ident">from_dataset</span>(</p><p>cls, dataset)</p>
    </div>
    

    
  
    <div class="desc"><p>Typically not used, this will read the raw outputs of a Dampr stage 
as an input.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.Dampr.from_dataset', this);">Show source &equiv;</a></p>
  <div id="source-dampr.Dampr.from_dataset" class="source">
    <pre><code>@classmethod
def from_dataset(cls, dataset):
    """
    Typically not used, this will read the raw outputs of a Dampr stage 
    as an input.
    """
    assert isinstance(dataset, Chunker)
    source, ng = Graph().add_input(dataset)
    return PMap(source, Dampr(ng))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.Dampr.json">
    <p>def <span class="ident">json</span>(</p><p>cls, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Convenience function which reads newline-delimited json records.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.Dampr.json', this);">Show source &equiv;</a></p>
  <div id="source-dampr.Dampr.json" class="source">
    <pre><code>@classmethod
def json(cls, *args, **kwargs):
    """
    Convenience function which reads newline-delimited json records.
    """
    return cls.text(*args, **kwargs).map(json.loads)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.Dampr.memory">
    <p>def <span class="ident">memory</span>(</p><p>cls, items, partitions=50)</p>
    </div>
    

    
  
    <div class="desc"><p>Create an in-memory dataset from the provided items.  <code>partitions</code> define how
many initial functions there will be.</p>
<pre><code>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5])
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.Dampr.memory', this);">Show source &equiv;</a></p>
  <div id="source-dampr.Dampr.memory" class="source">
    <pre><code>@classmethod
def memory(cls, items, partitions=50):
    """
    Create an in-memory dataset from the provided items.  `partitions` define how
    many initial functions there will be.
        >>> Dampr.memory([1,2,3,4,5])
    """
    mi = MemoryInput(list(enumerate(items)), partitions)
    source, ng = Graph().add_input(mi)
    return PMap(source, Dampr(ng))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.Dampr.read_input">
    <p>def <span class="ident">read_input</span>(</p><p>self, *datasets)</p>
    </div>
    

    
  
    <div class="desc"><p>Reads from the provided datasets.  When provided multiple datasets, it treats
each as a separate partition.</p>
<p><code>read_input</code> can also take Chunker, which lazily returns a set of Datasets to
operate over.</p>
<pre><code>&gt;&gt;&gt; from dampr.inputs import MemoryInput
&gt;&gt;&gt; Dampr.read_input(MemoryInput(enumerate(range(5,10)), 2))
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.Dampr.read_input', this);">Show source &equiv;</a></p>
  <div id="source-dampr.Dampr.read_input" class="source">
    <pre><code>@classmethod
def read_input(self, *datasets):
    """
    Reads from the provided datasets.  When provided multiple datasets, it treats
    each as a separate partition.
    `read_input` can also take Chunker, which lazily returns a set of Datasets to
    operate over.
        >>> from dampr.inputs import MemoryInput
        >>> Dampr.read_input(MemoryInput(enumerate(range(5,10)), 2))
    """
    if len(datasets) == 1 and isinstance(datasets, Chunker):
        datasets = datasets[0]
    elif len(datasets) > 1:
        datasets = CatDataset(datasets)
    else:
        datasets = datasets[0]
    source, ng = Graph().add_input(datasets)
    return PMap(source, Dampr(ng))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.Dampr.run">
    <p>def <span class="ident">run</span>(</p><p>self, *pmers, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Runs a graph or set of graphs.</p>
<blockquote>
<blockquote>
<blockquote>
<p>foo = Dampr.memory([1,2,3,4,5])
bar = Dampr.memory([6,7,8,9,10])
left, right = Dampr.run(foo, bar)
left.read()
[1, 2, 3, 4, 5]
right.read()
[6, 7, 8, 9, 10]</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.Dampr.run', this);">Show source &equiv;</a></p>
  <div id="source-dampr.Dampr.run" class="source">
    <pre><code>@classmethod
def run(self, *pmers, **kwargs):
    """
    Runs a graph or set of graphs.
        >>> foo = Dampr.memory([1,2,3,4,5])
        >>> bar = Dampr.memory([6,7,8,9,10])
        >>> left, right = Dampr.run(foo, bar)
        >>> left.read()
        [1, 2, 3, 4, 5]
        >>> right.read()
        [6, 7, 8, 9, 10]
    """
    sources = []
    graph = None
    for i, pmer in enumerate(pmers):
        if isinstance(pmer, PMap):
            pmer = pmer.checkpoint()
        elif isinstance(pmer, PJoin):
            pmer = pmer.reduce(lambda l, r: (list(l), list(r)))
        
        if i == 0:
            graph = pmer.pmer.graph
        else:
            graph = pmer.pmer.graph.union(graph)
        sources.append(pmer.source)
    name = kwargs.pop('name', 'dampr/{}'.format(random.random()))
    ds = pmer.pmer.runner(name, graph, **kwargs).run(sources)
    return [ValueEmitter(d) for d in ds]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.Dampr.text">
    <p>def <span class="ident">text</span>(</p><p>cls, fname, chunk_size=16777216)</p>
    </div>
    

    
  
    <div class="desc"><p>Reads a file or directory of files into Dampr.  Each record is assumed to 
be newline delimited.  </p>
<p>When fname is a directory, it will walk the directory, collecting all
files within it as part of the collection.</p>
<p><code>chunk_size</code> describes how big each map portion will be.</p>
<p>Returns a PMap object.</p>
<pre><code>&gt;&gt;&gt; Dampr.text('/tmp', chunk_size=64*1024**2)
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.Dampr.text', this);">Show source &equiv;</a></p>
  <div id="source-dampr.Dampr.text" class="source">
    <pre><code>@classmethod
def text(cls, fname, chunk_size=16*1024**2):
    """
    Reads a file or directory of files into Dampr.  Each record is assumed to 
    be newline delimited.  
    When fname is a directory, it will walk the directory, collecting all
    files within it as part of the collection.
    
    `chunk_size` describes how big each map portion will be.
    Returns a PMap object.
        >>> Dampr.text('/tmp', chunk_size=64*1024**2)
    """
    if os.path.isdir(fname):
        inp = DirectoryInput(fname, chunk_size)
    else:
        inp = TextInput(fname, chunk_size)
    source, ng = Graph().add_input(inp)
    return PMap(source, Dampr(ng))
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="dampr.PJoin" class="name">class <span class="ident">PJoin</span></p>
      
  
    <div class="desc"><p>Performs different types of joins between two grouped datasets.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PJoin', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PJoin" class="source">
    <pre><code>class PJoin(PBase):
    """
    Performs different types of joins between two grouped datasets.
    """

    def __init__(self, source, pmer, right):
        super(PJoin, self).__init__(source, pmer)
        self.right = right

    def run(self, name=None, **kwargs):
        return self.reduce(lambda l, r: (list(l), list(r))).run(name, **kwargs)

    def reduce(self, aggregate, many=False):
        """
        Performs an inner join between two datasets.  The aggregate function
        will be provied two arguments: the left iterator and the right iterator.


            >>> left = Dampr.memory([("foo", 13), ("bar", 14)]).group_by(lambda x: x[0])
            >>> right = Dampr.memory([("bar", "baller"), ("baz", "bag")]).group_by(lambda x: x[0])
            >>> left.join(right).reduce(lambda lit, rit: (list(lit), list(rit))).read()
            [('bar', ([('bar', 14)], [('bar', 'baller')]))]


        If `many` is True, reduce will flatten the output into seperate records:

            >>> left.join(right).reduce(lambda lit, rit: list(lit) + list(rit), many=True).read()
            [('bar', ('bar', 14)), ('bar', ('bar', 'baller'))]
        """
        def _reduce(k, left, right):
            return aggregate(left, right)

        source, pmer = self.pmer._add_reducer([self.source, self.right], 
                KeyedInnerJoin(_reduce, many))
        return PMap(source, pmer)

    def left_reduce(self, aggregate):
        """
        Performs a left join on two datasets.  In the case where the right dataset
        is missing the join key, it will call the aggregate function with an empty
        iterator.

            >>> left = Dampr.memory([("foo", 13), ("bar", 14)]).group_by(lambda x: x[0])
            >>> right = Dampr.memory([("bar", "baller"), ("baz", "bag")]).group_by(lambda x: x[0])
            >>> left.join(right).left_reduce(lambda lit, rit: (list(lit), list(rit))).read()
            [('bar', ([('bar', 14)], [('bar', 'baller')])), ('foo', ([('foo', 13)], []))]
        """
        def _reduce(k, left, right):
            return aggregate(left, right)

        source, pmer = self.pmer._add_reducer([self.source, self.right], 
                KeyedLeftJoin(_reduce))
        return PMap(source, pmer)

    def _cross(self, crosser):
        def _cross(k1, v1, k2, v2):
            return k1, crosser(v1, v2)

        source, pmer = self.pmer._add_reducer([self.source, self.right],
                KeyedCrossJoin(_cross))

        return PMap(source, pmer).map(lambda x: x[1])
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#dampr.PJoin">PJoin</a></li>
          <li>dampr.dampr.PBase</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="dampr.PJoin.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, source, pmer, right)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PJoin.__init__', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PJoin.__init__" class="source">
    <pre><code>def __init__(self, source, pmer, right):
    super(PJoin, self).__init__(source, pmer)
    self.right = right
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PJoin.left_reduce">
    <p>def <span class="ident">left_reduce</span>(</p><p>self, aggregate)</p>
    </div>
    

    
  
    <div class="desc"><p>Performs a left join on two datasets.  In the case where the right dataset
is missing the join key, it will call the aggregate function with an empty
iterator.</p>
<pre><code>&gt;&gt;&gt; left = Dampr.memory([("foo", 13), ("bar", 14)]).group_by(lambda x: x[0])
&gt;&gt;&gt; right = Dampr.memory([("bar", "baller"), ("baz", "bag")]).group_by(lambda x: x[0])
&gt;&gt;&gt; left.join(right).left_reduce(lambda lit, rit: (list(lit), list(rit))).read()
[('bar', ([('bar', 14)], [('bar', 'baller')])), ('foo', ([('foo', 13)], []))]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PJoin.left_reduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PJoin.left_reduce" class="source">
    <pre><code>def left_reduce(self, aggregate):
    """
    Performs a left join on two datasets.  In the case where the right dataset
    is missing the join key, it will call the aggregate function with an empty
    iterator.
        >>> left = Dampr.memory([("foo", 13), ("bar", 14)]).group_by(lambda x: x[0])
        >>> right = Dampr.memory([("bar", "baller"), ("baz", "bag")]).group_by(lambda x: x[0])
        >>> left.join(right).left_reduce(lambda lit, rit: (list(lit), list(rit))).read()
        [('bar', ([('bar', 14)], [('bar', 'baller')])), ('foo', ([('foo', 13)], []))]
    """
    def _reduce(k, left, right):
        return aggregate(left, right)
    source, pmer = self.pmer._add_reducer([self.source, self.right], 
            KeyedLeftJoin(_reduce))
    return PMap(source, pmer)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PJoin.read">
    <p>def <span class="ident">read</span>(</p><p>self, k=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Shorthand for run() followed by a read()</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PJoin.read', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PJoin.read" class="source">
    <pre><code>def read(self, k=None, **kwargs):
    """
    Shorthand for run() followed by a read()
    """
    return self.run(**kwargs).read(k)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PJoin.reduce">
    <p>def <span class="ident">reduce</span>(</p><p>self, aggregate, many=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Performs an inner join between two datasets.  The aggregate function
will be provied two arguments: the left iterator and the right iterator.</p>
<pre><code>&gt;&gt;&gt; left = Dampr.memory([("foo", 13), ("bar", 14)]).group_by(lambda x: x[0])
&gt;&gt;&gt; right = Dampr.memory([("bar", "baller"), ("baz", "bag")]).group_by(lambda x: x[0])
&gt;&gt;&gt; left.join(right).reduce(lambda lit, rit: (list(lit), list(rit))).read()
[('bar', ([('bar', 14)], [('bar', 'baller')]))]
</code></pre>
<p>If <code>many</code> is True, reduce will flatten the output into seperate records:</p>
<pre><code>&gt;&gt;&gt; left.join(right).reduce(lambda lit, rit: list(lit) + list(rit), many=True).read()
[('bar', ('bar', 14)), ('bar', ('bar', 'baller'))]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PJoin.reduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PJoin.reduce" class="source">
    <pre><code>def reduce(self, aggregate, many=False):
    """
    Performs an inner join between two datasets.  The aggregate function
    will be provied two arguments: the left iterator and the right iterator.
        >>> left = Dampr.memory([("foo", 13), ("bar", 14)]).group_by(lambda x: x[0])
        >>> right = Dampr.memory([("bar", "baller"), ("baz", "bag")]).group_by(lambda x: x[0])
        >>> left.join(right).reduce(lambda lit, rit: (list(lit), list(rit))).read()
        [('bar', ([('bar', 14)], [('bar', 'baller')]))]
    If `many` is True, reduce will flatten the output into seperate records:
        >>> left.join(right).reduce(lambda lit, rit: list(lit) + list(rit), many=True).read()
        [('bar', ('bar', 14)), ('bar', ('bar', 'baller'))]
    """
    def _reduce(k, left, right):
        return aggregate(left, right)
    source, pmer = self.pmer._add_reducer([self.source, self.right], 
            KeyedInnerJoin(_reduce, many))
    return PMap(source, pmer)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PJoin.run">
    <p>def <span class="ident">run</span>(</p><p>self, name=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Evaluates the composed Dampr graph with the provided name and subsequent options.
By default, uses /tmp as temporary storage.</p>
<p>Returns a ValueEmitter useful for shell access.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PJoin.run', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PJoin.run" class="source">
    <pre><code>def run(self, name=None, **kwargs):
    return self.reduce(lambda l, r: (list(l), list(r))).run(name, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="dampr.PJoin.right" class="name">var <span class="ident">right</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="dampr.PMap" class="name">class <span class="ident">PMap</span></p>
      
  
    <div class="desc"><p>Represents most mapping processes.  Internally, it collects consecutive mapping operations
and fuses them together into a single operation, speeding up many types of operations.</p>
<p>This class shouldn't be intialized manually.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap" class="source">
    <pre><code>class PMap(PBase):
    """
    Represents most mapping processes.  Internally, it collects consecutive mapping operations
    and fuses them together into a single operation, speeding up many types of operations.

    This class shouldn't be intialized manually.
    """

    def __init__(self, source, pmer, agg=None):
        super(PMap, self).__init__(source, pmer)
        self.agg = [] if agg is None else agg

    def run(self, name=None, **kwargs):
        """
        Run the defined graph.
        """
        if len(self.agg) > 0:
            return self.checkpoint().run(name, **kwargs)
        else:
            return super(PMap, self).run(name, **kwargs)

    def _add_mapper(self, mapper):
        assert isinstance(mapper, Streamable)
        # If we have a fusable mapper, just add it to the set.
        return PMap(self.source, self.pmer, self.agg + [mapper])

    def _add_map(self, f):
        return self._add_mapper(Map(f))

    def sample(self, prob):
        """
        Samples data with a given probability.  For example:
        
        `graph.sample(0.1)` will uniformly sample 10% of the data in the collection.
        """
        assert 0 <= prob <= 1.0

        def _sample(k, v):
            if get_rand().random() < prob:
                yield k, v

        return self._add_map(_sample)
        
    def checkpoint(self, force=False, combiner=None, options=None):
        """
        Checkpoint forces Dampr to fuse all cached maps and add it as a MR stage.

        This is useful when sharing the results of a computation with multiple other graphs.
        
        Without checkpoint(), Dampr would execute the shared graph multiple times rather than reuse
        the results of the computation:

            >>> evens = Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 0).checkpoint()
            >>> summed = evens.group_by(lambda x: 1).sum()
            >>> multiplied = evens.group_by(lambda x: 1).reduce(lambda x, y: x * y)

        """
        if len(self.agg) > 0 or force:
            aggs = [Map(_identity)] if len(self.agg) == 0 else self.agg[:]
            name = ' -> ' .join('{}'.format(str(a)) for a in aggs)
            name = 'Stage {}: %s' % (name)
            source, pmer = self.pmer._add_mapper([self.source], 
                    fuse(aggs), 
                    combiner=combiner,
                    name=name,
                    options=options)
            return PMap(source, pmer) 

        return self

    def custom_mapper(self, mapper, name=None, **options):
        """
        Custom Mapper provides a low-level interface to the underlying map function.
        Users can provide any instance which adhere's to the Mapper interface, allowing
        for powerful or specific implementations.

        This is typically used very rarely and has some caveats such as not fusing
        with other Mappers.  Similarly, the implementer needs to understand more of the
        nuances associated with keys.

            >>> from dampr.base import Map
            >>> Dampr.memory([1,2,3,4,5]).custom_mapper(Map(lambda k, x: [(k, x+1)])).read()
            [2, 3, 4, 5, 6]
        """
        if isinstance(mapper, Streamable):
            return self._add_mapper(mapper)

        assert isinstance(mapper, Mapper)
        name = name if name is not None else str(mapper)
        me = self.checkpoint()
        source, pmer = me.pmer._add_mapper([me.source], 
                mapper,
                name=name,
                options=options)
        
        return PMap(source, pmer)

    def custom_reducer(self, reducer, name=None, **options):
        """
        Allows the user to provide any Reducer which adheres to the Reducer interface.
        This is a very powerful, low-level interface which should be avoided when possible
        as it's easy to write bugs.

            >>> Dampr.memory([1,2,3,4,5]).custom_reducer(Reduce(lambda k, x: [(k, sum(x))])).read()
            [[(0, 1)], [(1, 2)], [(2, 3)], [(3, 4)], [(4, 5)]]
        """
        assert isinstance(reducer, Reducer)
        me = self.checkpoint(force=True)
        name = name if name is not None else str(reducer)
        new_source, pmer = me.pmer._add_reducer([me.source], 
                reducer, 
                name=name,
                options=options)
        
        return PMap(new_source, pmer)

    def partition_map(self, f, **options):
        """
        Provides a medium-level interface for writing custom functionality for mapping 
        a partition.  This can be used for creating custom logic in mappers for the sake
        of performance or additional functionality.

        Note: partition_map will still execute even if the partition is empty!  Make sure
        the logic handles empty sets!

        `f` is a function that takes in an iterator of items in the partition and yields 
        out group keys and new values.


            >>> def plus_one(items):
            ...   for num in items:
            ...     yield num, num + 1
            ...
            >>> Dampr.memory([1,2,3,4,5]).partition_map(plus_one).read()
            [2, 3, 4, 5, 6]

        """
        return self.custom_mapper(StreamMapper(f), **options)

    def partition_reduce(self, f):
        """
        `partition_reduce` is a medium-level function that allows for more complex logic
        during reductions.  It can be useful in certain cases where reductions over sets
        of reduced values is convenient, such as returning only the top K items in a dataset

        Note: `partition_reduce` will still execute on empty partitions!  Make sure the
        logic handles cases where a partition is empty!

            >>> def largest_number(it):
            ...   largest = float('-inf')
            ...   for group_key, its in it:
            ...     for value in its:
            ...       largest = max(largest, value)
            ...   yield "Largest", largest
            ...
            >>> Dampr.memory([1,2,3,4,5]).partition_reduce(largest_number).read(n_partitions=1)
            [('Largest', 5)]
        """
        return self.custom_reducer(StreamReducer(f))

    def len(self):
        """
        Counts the number of items in the 
	collection.

	    >>> Dampr.memory([1,2,3,4,5]).len().read()
	    [5]
        """

        def _map_count(items):
            count = 0
            for _ in items:
                count += 1

            yield 1, count

        def _reduce_count(groups):
            count = 0
            not_empty = False
            for _, counts in groups:
                not_empty = True
                for c in counts:
                    count += c

            if not_empty:
                yield 1, count

        return self \
                .partition_map(_map_count) \
                .partition_reduce(_reduce_count) \
                .map(lambda x: x[1])

    def map(self, f):
        """
        Maps elements in the underlying collection using function 
        `f`:

            >>> Dampr.memory([1,2,3,4,5]).map(lambda x: x + 1).read()
            [2, 3, 4, 5, 6]
        """
        def _map(k, v):
            yield k, f(v)

        return self._add_map(_map)

    def filter(self, f):
        """
        Filters items from a collection based on a predicate f.
        A predicate return True keeps the item.

            >>> Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 1).read()
            [1, 3, 5]

        """
        def _filter(k, v):
            if f(v):
                yield k, v

        return self._add_map(_filter)

    def flat_map(self, f):
        """
        Maps elements in the underlying collection using function f, 
        flattening the results

            >>> Dampr.memory([1,2,3,4,5]).flat_map(range).read()
            [0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4]
        """
        def _flat_map(k, v):
            for vi in f(v):
                yield k, vi

        return self._add_map(_flat_map)

    def group_by(self, key, vf=lambda x: x):
        """
        Groups a collections of X by a key function, optionally mapping X to Y 
        using `vf`.  Returns a Reducer object for different types of aggregations

            >>> Dampr.memory([1,2,3,4,5]).group_by(lambda x: x % 2).reduce(lambda k, it: sum(it)).read()
            [(0, 6), (1, 9)]
        """
        def _group_by(_key, value):
            yield key(value), vf(value)

        pm = self._add_map(_group_by).checkpoint()
        return PReduce(pm.source, pm.pmer)

    def a_group_by(self, key, vf=lambda x: x):
        """
        Groups a collection of X by a key function and optionally mapping X to Y
        using `vf`.  It differs from `group_by` by requiring an associative reduction
        operator: by forcing this restriction, Dampr is able to perform a partial 
        reduction of the collection during the mapping sequence which can dramatically
        speed up the performace of the reduce stage.

        When possible, use a_group_by over the more general group_by.

            >>> Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).reduce(lambda x, y: x+y).read()
            [(0, 6), (1, 9)]
        """
        def _a_group_by(_key, value):
            yield key(value), vf(value)

        # We don't checkpoint here!
        pm = self._add_map(_a_group_by)
        return ARReduce(pm)

    def fold_by(self, key, binop, value=lambda x: x, **options):
        """
        Shortcut for a_group_by(key, value).reduce(binop)
        """
        return self.a_group_by(key, value).reduce(binop, **options)

    def sort_by(self, key, **options):
        """
        Sorts the results by a given key function.
        
            >>> Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 1).sort_by(lambda x: -x).read()
            [5, 3, 1]
        """
        def _sort_by(_key, value):
            yield key(value), value

        return self._add_map(_sort_by).checkpoint(options=options)

    def join(self, other):
        """
        Joins two independent computations, returning a Joining class.

        This is a powerful and expensive operation which can merge two Dampr 
        collections together.
        """
        assert isinstance(other, PBase)
        me = self.checkpoint(True)
        if isinstance(other, PMap):
            other = other.checkpoint(True)

        pmer = Dampr(me.pmer.graph.union(other.pmer.graph))
        return PJoin(me.source, pmer, other.source)

    def count(self, key=lambda x: x, **options):
        """
        Counts each item X in the collection by its key 
        function.

            >>> Dampr.memory([1,2,3,4,5]).count(lambda x: x % 2).read()
            [(0, 2), (1, 3)]
        """
        return self.a_group_by(key, lambda v: 1) \
                .reduce(operator.add, **options)

    def mean(self, key=lambda x: 1, value=lambda x: x, **options):
        """
        Finds the mean of X, grouped by its key function and optionally
        mapped by a value function:

            >>> ages = [("Andrew", 33), ("Alice", 42), ("Andrew", 12), ("Bob", 51)]
            >>> Dampr.memory(ages).mean(lambda x: x[0], lambda v: v[1]).read()
            [('Alice', 42.0), ('Andrew', 22.5), ('Bob', 51.0)]
        """
        def _mean_binop(x, y):
            return x[0] + y[0], x[1] + y[1]

        def _average(x):
            return (x[0], x[1][0] / float(x[1][1]))

        return self.a_group_by(key, lambda v: (value(v), 1)) \
                .reduce(_mean_binop, **options) \
                .map(_average)

    def inspect(self, prefix="", exit=False):
        """
        Inspect is a debug function which prints each item X that flows through
        it.  It's valueable in inspecting intermediate results of a pipeline 
        without changing the values internally.
        """
        def _inspect(k, v):
            print("{}: {}".format(prefix, v))
            yield k, v

        ins = self._add_map(_inspect)
        if exit:
            ins.run()
            sys.exit(0)

        return ins

    def cached(self, **options):
        """
        The cached function runs a graph and stores it in memory.  This is 
        useful for small datasets to gain extra performance in subsequent 
        computations.

            >>> Dampr.memory([1,2,3,4,5,6]).mean(lambda x: x % 2).cached().read()
            [(0, 4.0), (1, 3.0)]
        """
        # Run the pipeline, load it into memory, and create a new graph
        options['memory'] = True
        return self.checkpoint(options=options)

    def sink(self, path):
        """
        Since writes each X in a collection to a given path.  The path will
        create a directory and write each map or reduce partition into the
        directory as partitions.  Sink assumes each X in the collection is 
        already a unicode string.

            >>> Dampr.memory(["foo", "bar", "baz"]).sink("/tmp/foo").run()
            >>> open("/tmp/foo/0").read()
            >>> open("/tmp/foo/1").read()
            >>> open("/tmp/foo/2").read()
    """
        aggs = [Map(_identity)] if len(self.agg) == 0 else self.agg[:]
        name = ' -> ' .join('{}'.format(a.mapper.__name__) for a in aggs)
        name = 'Stage {}: %s' % (name)
        source, pmer = self.pmer._add_sink([self.source], 
                fuse(aggs), 
                path=path,
                name=name,
                options=None)
        return PMap(source, pmer) 

    def sink_tsv(self, path):
        """
        A convenience function which takes a tuple or list, creates a simple
        tab-delimited output, and sinks it to the provided path:

            >>> Dampr.memory([("Hank Aaron", 755)]).sink_tsv("/tmp/foo").run()
            >>> open("/tmp/foo/0").read()
        """
        return self.map(lambda x: u'\t'.join(unicode(p) for p in x)).sink(path)

    def sink_json(self, path):
        """
        A convenience function which takes a simple python object and serializes
        it to a line-delimited json to the given path:

            >>> Dampr.memory([{"name": "Hank Aaron", "home runs": 755}]).sink_json("/tmp/foo").run()
            >>> open("/tmp/foo/0").read()
        """
        return self.map(json.dumps).sink(path)

    def cross_right(self, other, cross, memory=False):
        """
        Produces the cross product between two datasets during the map stage.
        This is an incredibly expensive operation when done against two large
        datasets.  

        When it is known that the right dataset is small, setting `memory` to `True`
        will cache the right dataset in memory, speeding up the computation significantly.

        Two items, Xi and Yi, are joined with the cross function.

            >>> left = Dampr.memory([1,2,3,4,5])
            >>> right = Dampr.memory(['foo', 'bar'])
            >>> left.cross_right(right, lambda x, y: (x, y)).read()
            [(1, 'foo'), (1, 'bar'), (2, 'foo'), (2, 'bar'), (3, 'foo'), (3, 'bar'), (4, 'foo'), (4, 'bar'), (5, 'foo'), (5, 'bar')]
        """
        assert isinstance(other, PMap)
        return other.cross_left(self, lambda xi, yi: cross(yi, xi), memory)

    def cross_left(self, other, cross, memory=False, **options):
        """
        Produces the cross product between two datasets during the map stage.
        This is an incredibly expensive operation when done against two large
        datasets.  

        When it is known that the left dataset is small, setting `memory` to `True`
        will cache the right dataset in memory, speeding up the computation significantly.

        Two items, Xi and Yi, are joined with the cross function.

            >>> left = Dampr.memory([1,2,3,4,5])
            >>> right = Dampr.memory(['foo', 'bar'])
            >>> left.cross_left(right, lambda x, y: (x, y)).read()
            [(1, 'foo'), (2, 'foo'), (3, 'foo'), (4, 'foo'), (5, 'foo'), (1, 'bar'), (2, 'bar'), (3, 'bar'), (4, 'bar'), (5, 'bar')]
        """
        def _cross(k1, v1, k2, v2):
            yield k1, cross(v2, v1)

        me = self.checkpoint()
        other = other.checkpoint()
        pmer = Dampr(me.pmer.graph.union(other.pmer.graph))
        name = 'Stage {}: Cross'
        source, pmer = pmer._add_mapper([other.source, me.source], 
                MapCrossJoin(_cross, cache=memory), 
                combiner=None,
                name=name,
                options=options)
        return PMap(source, pmer) 
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#dampr.PMap">PMap</a></li>
          <li>dampr.dampr.PBase</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="dampr.PMap.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, source, pmer, agg=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.__init__', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.__init__" class="source">
    <pre><code>def __init__(self, source, pmer, agg=None):
    super(PMap, self).__init__(source, pmer)
    self.agg = [] if agg is None else agg
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.a_group_by">
    <p>def <span class="ident">a_group_by</span>(</p><p>self, key, vf=&lt;function PMap.&lt;lambda&gt; at 0x7fa514f37bf8&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Groups a collection of X by a key function and optionally mapping X to Y
using <code>vf</code>.  It differs from <code>group_by</code> by requiring an associative reduction
operator: by forcing this restriction, Dampr is able to perform a partial 
reduction of the collection during the mapping sequence which can dramatically
speed up the performace of the reduce stage.</p>
<p>When possible, use a_group_by over the more general group_by.</p>
<pre><code>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).reduce(lambda x, y: x+y).read()
[(0, 6), (1, 9)]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.a_group_by', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.a_group_by" class="source">
    <pre><code>def a_group_by(self, key, vf=lambda x: x):
    """
    Groups a collection of X by a key function and optionally mapping X to Y
    using `vf`.  It differs from `group_by` by requiring an associative reduction
    operator: by forcing this restriction, Dampr is able to perform a partial 
    reduction of the collection during the mapping sequence which can dramatically
    speed up the performace of the reduce stage.
    When possible, use a_group_by over the more general group_by.
        >>> Dampr.memory([1,2,3,4,5]).a_group_by(lambda x: x % 2).reduce(lambda x, y: x+y).read()
        [(0, 6), (1, 9)]
    """
    def _a_group_by(_key, value):
        yield key(value), vf(value)
    # We don't checkpoint here!
    pm = self._add_map(_a_group_by)
    return ARReduce(pm)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.cached">
    <p>def <span class="ident">cached</span>(</p><p>self, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>The cached function runs a graph and stores it in memory.  This is 
useful for small datasets to gain extra performance in subsequent 
computations.</p>
<pre><code>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5,6]).mean(lambda x: x % 2).cached().read()
[(0, 4.0), (1, 3.0)]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.cached', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.cached" class="source">
    <pre><code>def cached(self, **options):
    """
    The cached function runs a graph and stores it in memory.  This is 
    useful for small datasets to gain extra performance in subsequent 
    computations.
        >>> Dampr.memory([1,2,3,4,5,6]).mean(lambda x: x % 2).cached().read()
        [(0, 4.0), (1, 3.0)]
    """
    # Run the pipeline, load it into memory, and create a new graph
    options['memory'] = True
    return self.checkpoint(options=options)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.checkpoint">
    <p>def <span class="ident">checkpoint</span>(</p><p>self, force=False, combiner=None, options=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Checkpoint forces Dampr to fuse all cached maps and add it as a MR stage.</p>
<p>This is useful when sharing the results of a computation with multiple other graphs.</p>
<p>Without checkpoint(), Dampr would execute the shared graph multiple times rather than reuse
the results of the computation:</p>
<pre><code>&gt;&gt;&gt; evens = Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 0).checkpoint()
&gt;&gt;&gt; summed = evens.group_by(lambda x: 1).sum()
&gt;&gt;&gt; multiplied = evens.group_by(lambda x: 1).reduce(lambda x, y: x * y)
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.checkpoint', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.checkpoint" class="source">
    <pre><code>def checkpoint(self, force=False, combiner=None, options=None):
    """
    Checkpoint forces Dampr to fuse all cached maps and add it as a MR stage.
    This is useful when sharing the results of a computation with multiple other graphs.
    
    Without checkpoint(), Dampr would execute the shared graph multiple times rather than reuse
    the results of the computation:
        >>> evens = Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 0).checkpoint()
        >>> summed = evens.group_by(lambda x: 1).sum()
        >>> multiplied = evens.group_by(lambda x: 1).reduce(lambda x, y: x * y)
    """
    if len(self.agg) > 0 or force:
        aggs = [Map(_identity)] if len(self.agg) == 0 else self.agg[:]
        name = ' -> ' .join('{}'.format(str(a)) for a in aggs)
        name = 'Stage {}: %s' % (name)
        source, pmer = self.pmer._add_mapper([self.source], 
                fuse(aggs), 
                combiner=combiner,
                name=name,
                options=options)
        return PMap(source, pmer) 
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.count">
    <p>def <span class="ident">count</span>(</p><p>self, key=&lt;function PMap.&lt;lambda&gt; at 0x7fa514f37f28&gt;, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Counts each item X in the collection by its key 
function.</p>
<pre><code>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).count(lambda x: x % 2).read()
[(0, 2), (1, 3)]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.count', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.count" class="source">
    <pre><code>def count(self, key=lambda x: x, **options):
    """
    Counts each item X in the collection by its key 
    function.
        >>> Dampr.memory([1,2,3,4,5]).count(lambda x: x % 2).read()
        [(0, 2), (1, 3)]
    """
    return self.a_group_by(key, lambda v: 1) \
            .reduce(operator.add, **options)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.cross_left">
    <p>def <span class="ident">cross_left</span>(</p><p>self, other, cross, memory=False, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Produces the cross product between two datasets during the map stage.
This is an incredibly expensive operation when done against two large
datasets.  </p>
<p>When it is known that the left dataset is small, setting <code>memory</code> to <code>True</code>
will cache the right dataset in memory, speeding up the computation significantly.</p>
<p>Two items, Xi and Yi, are joined with the cross function.</p>
<pre><code>&gt;&gt;&gt; left = Dampr.memory([1,2,3,4,5])
&gt;&gt;&gt; right = Dampr.memory(['foo', 'bar'])
&gt;&gt;&gt; left.cross_left(right, lambda x, y: (x, y)).read()
[(1, 'foo'), (2, 'foo'), (3, 'foo'), (4, 'foo'), (5, 'foo'), (1, 'bar'), (2, 'bar'), (3, 'bar'), (4, 'bar'), (5, 'bar')]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.cross_left', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.cross_left" class="source">
    <pre><code>def cross_left(self, other, cross, memory=False, **options):
    """
    Produces the cross product between two datasets during the map stage.
    This is an incredibly expensive operation when done against two large
    datasets.  
    When it is known that the left dataset is small, setting `memory` to `True`
    will cache the right dataset in memory, speeding up the computation significantly.
    Two items, Xi and Yi, are joined with the cross function.
        >>> left = Dampr.memory([1,2,3,4,5])
        >>> right = Dampr.memory(['foo', 'bar'])
        >>> left.cross_left(right, lambda x, y: (x, y)).read()
        [(1, 'foo'), (2, 'foo'), (3, 'foo'), (4, 'foo'), (5, 'foo'), (1, 'bar'), (2, 'bar'), (3, 'bar'), (4, 'bar'), (5, 'bar')]
    """
    def _cross(k1, v1, k2, v2):
        yield k1, cross(v2, v1)
    me = self.checkpoint()
    other = other.checkpoint()
    pmer = Dampr(me.pmer.graph.union(other.pmer.graph))
    name = 'Stage {}: Cross'
    source, pmer = pmer._add_mapper([other.source, me.source], 
            MapCrossJoin(_cross, cache=memory), 
            combiner=None,
            name=name,
            options=options)
    return PMap(source, pmer) 
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.cross_right">
    <p>def <span class="ident">cross_right</span>(</p><p>self, other, cross, memory=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Produces the cross product between two datasets during the map stage.
This is an incredibly expensive operation when done against two large
datasets.  </p>
<p>When it is known that the right dataset is small, setting <code>memory</code> to <code>True</code>
will cache the right dataset in memory, speeding up the computation significantly.</p>
<p>Two items, Xi and Yi, are joined with the cross function.</p>
<pre><code>&gt;&gt;&gt; left = Dampr.memory([1,2,3,4,5])
&gt;&gt;&gt; right = Dampr.memory(['foo', 'bar'])
&gt;&gt;&gt; left.cross_right(right, lambda x, y: (x, y)).read()
[(1, 'foo'), (1, 'bar'), (2, 'foo'), (2, 'bar'), (3, 'foo'), (3, 'bar'), (4, 'foo'), (4, 'bar'), (5, 'foo'), (5, 'bar')]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.cross_right', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.cross_right" class="source">
    <pre><code>def cross_right(self, other, cross, memory=False):
    """
    Produces the cross product between two datasets during the map stage.
    This is an incredibly expensive operation when done against two large
    datasets.  
    When it is known that the right dataset is small, setting `memory` to `True`
    will cache the right dataset in memory, speeding up the computation significantly.
    Two items, Xi and Yi, are joined with the cross function.
        >>> left = Dampr.memory([1,2,3,4,5])
        >>> right = Dampr.memory(['foo', 'bar'])
        >>> left.cross_right(right, lambda x, y: (x, y)).read()
        [(1, 'foo'), (1, 'bar'), (2, 'foo'), (2, 'bar'), (3, 'foo'), (3, 'bar'), (4, 'foo'), (4, 'bar'), (5, 'foo'), (5, 'bar')]
    """
    assert isinstance(other, PMap)
    return other.cross_left(self, lambda xi, yi: cross(yi, xi), memory)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.custom_mapper">
    <p>def <span class="ident">custom_mapper</span>(</p><p>self, mapper, name=None, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Custom Mapper provides a low-level interface to the underlying map function.
Users can provide any instance which adhere's to the Mapper interface, allowing
for powerful or specific implementations.</p>
<p>This is typically used very rarely and has some caveats such as not fusing
with other Mappers.  Similarly, the implementer needs to understand more of the
nuances associated with keys.</p>
<pre><code>&gt;&gt;&gt; from dampr.base import Map
&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).custom_mapper(Map(lambda k, x: [(k, x+1)])).read()
[2, 3, 4, 5, 6]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.custom_mapper', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.custom_mapper" class="source">
    <pre><code>def custom_mapper(self, mapper, name=None, **options):
    """
    Custom Mapper provides a low-level interface to the underlying map function.
    Users can provide any instance which adhere's to the Mapper interface, allowing
    for powerful or specific implementations.
    This is typically used very rarely and has some caveats such as not fusing
    with other Mappers.  Similarly, the implementer needs to understand more of the
    nuances associated with keys.
        >>> from dampr.base import Map
        >>> Dampr.memory([1,2,3,4,5]).custom_mapper(Map(lambda k, x: [(k, x+1)])).read()
        [2, 3, 4, 5, 6]
    """
    if isinstance(mapper, Streamable):
        return self._add_mapper(mapper)
    assert isinstance(mapper, Mapper)
    name = name if name is not None else str(mapper)
    me = self.checkpoint()
    source, pmer = me.pmer._add_mapper([me.source], 
            mapper,
            name=name,
            options=options)
    
    return PMap(source, pmer)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.custom_reducer">
    <p>def <span class="ident">custom_reducer</span>(</p><p>self, reducer, name=None, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Allows the user to provide any Reducer which adheres to the Reducer interface.
This is a very powerful, low-level interface which should be avoided when possible
as it's easy to write bugs.</p>
<pre><code>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).custom_reducer(Reduce(lambda k, x: [(k, sum(x))])).read()
[[(0, 1)], [(1, 2)], [(2, 3)], [(3, 4)], [(4, 5)]]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.custom_reducer', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.custom_reducer" class="source">
    <pre><code>def custom_reducer(self, reducer, name=None, **options):
    """
    Allows the user to provide any Reducer which adheres to the Reducer interface.
    This is a very powerful, low-level interface which should be avoided when possible
    as it's easy to write bugs.
        >>> Dampr.memory([1,2,3,4,5]).custom_reducer(Reduce(lambda k, x: [(k, sum(x))])).read()
        [[(0, 1)], [(1, 2)], [(2, 3)], [(3, 4)], [(4, 5)]]
    """
    assert isinstance(reducer, Reducer)
    me = self.checkpoint(force=True)
    name = name if name is not None else str(reducer)
    new_source, pmer = me.pmer._add_reducer([me.source], 
            reducer, 
            name=name,
            options=options)
    
    return PMap(new_source, pmer)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.filter">
    <p>def <span class="ident">filter</span>(</p><p>self, f)</p>
    </div>
    

    
  
    <div class="desc"><p>Filters items from a collection based on a predicate f.
A predicate return True keeps the item.</p>
<pre><code>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 1).read()
[1, 3, 5]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.filter', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.filter" class="source">
    <pre><code>def filter(self, f):
    """
    Filters items from a collection based on a predicate f.
    A predicate return True keeps the item.
        >>> Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 1).read()
        [1, 3, 5]
    """
    def _filter(k, v):
        if f(v):
            yield k, v
    return self._add_map(_filter)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.flat_map">
    <p>def <span class="ident">flat_map</span>(</p><p>self, f)</p>
    </div>
    

    
  
    <div class="desc"><p>Maps elements in the underlying collection using function f, 
flattening the results</p>
<pre><code>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).flat_map(range).read()
[0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.flat_map', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.flat_map" class="source">
    <pre><code>def flat_map(self, f):
    """
    Maps elements in the underlying collection using function f, 
    flattening the results
        >>> Dampr.memory([1,2,3,4,5]).flat_map(range).read()
        [0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4]
    """
    def _flat_map(k, v):
        for vi in f(v):
            yield k, vi
    return self._add_map(_flat_map)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.fold_by">
    <p>def <span class="ident">fold_by</span>(</p><p>self, key, binop, value=&lt;function PMap.&lt;lambda&gt; at 0x7fa514f37d08&gt;, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Shortcut for a_group_by(key, value).reduce(binop)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.fold_by', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.fold_by" class="source">
    <pre><code>def fold_by(self, key, binop, value=lambda x: x, **options):
    """
    Shortcut for a_group_by(key, value).reduce(binop)
    """
    return self.a_group_by(key, value).reduce(binop, **options)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.group_by">
    <p>def <span class="ident">group_by</span>(</p><p>self, key, vf=&lt;function PMap.&lt;lambda&gt; at 0x7fa514f37ae8&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Groups a collections of X by a key function, optionally mapping X to Y 
using <code>vf</code>.  Returns a Reducer object for different types of aggregations</p>
<pre><code>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).group_by(lambda x: x % 2).reduce(lambda k, it: sum(it)).read()
[(0, 6), (1, 9)]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.group_by', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.group_by" class="source">
    <pre><code>def group_by(self, key, vf=lambda x: x):
    """
    Groups a collections of X by a key function, optionally mapping X to Y 
    using `vf`.  Returns a Reducer object for different types of aggregations
        >>> Dampr.memory([1,2,3,4,5]).group_by(lambda x: x % 2).reduce(lambda k, it: sum(it)).read()
        [(0, 6), (1, 9)]
    """
    def _group_by(_key, value):
        yield key(value), vf(value)
    pm = self._add_map(_group_by).checkpoint()
    return PReduce(pm.source, pm.pmer)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.inspect">
    <p>def <span class="ident">inspect</span>(</p><p>self, prefix=&#39;&#39;, exit=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Inspect is a debug function which prints each item X that flows through
it.  It's valueable in inspecting intermediate results of a pipeline 
without changing the values internally.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.inspect', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.inspect" class="source">
    <pre><code>def inspect(self, prefix="", exit=False):
    """
    Inspect is a debug function which prints each item X that flows through
    it.  It's valueable in inspecting intermediate results of a pipeline 
    without changing the values internally.
    """
    def _inspect(k, v):
        print("{}: {}".format(prefix, v))
        yield k, v
    ins = self._add_map(_inspect)
    if exit:
        ins.run()
        sys.exit(0)
    return ins
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.join">
    <p>def <span class="ident">join</span>(</p><p>self, other)</p>
    </div>
    

    
  
    <div class="desc"><p>Joins two independent computations, returning a Joining class.</p>
<p>This is a powerful and expensive operation which can merge two Dampr 
collections together.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.join', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.join" class="source">
    <pre><code>def join(self, other):
    """
    Joins two independent computations, returning a Joining class.
    This is a powerful and expensive operation which can merge two Dampr 
    collections together.
    """
    assert isinstance(other, PBase)
    me = self.checkpoint(True)
    if isinstance(other, PMap):
        other = other.checkpoint(True)
    pmer = Dampr(me.pmer.graph.union(other.pmer.graph))
    return PJoin(me.source, pmer, other.source)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.len">
    <p>def <span class="ident">len</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Counts the number of items in the 
collection.</p>
<pre><code>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).len().read()
[5]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.len', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.len" class="source">
    <pre><code>def len(self):
    """
    Counts the number of items in the 
lection.
 >>> Dampr.memory([1,2,3,4,5]).len().read()
 [5]
    """
    def _map_count(items):
        count = 0
        for _ in items:
            count += 1
        yield 1, count
    def _reduce_count(groups):
        count = 0
        not_empty = False
        for _, counts in groups:
            not_empty = True
            for c in counts:
                count += c
        if not_empty:
            yield 1, count
    return self \
            .partition_map(_map_count) \
            .partition_reduce(_reduce_count) \
            .map(lambda x: x[1])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.map">
    <p>def <span class="ident">map</span>(</p><p>self, f)</p>
    </div>
    

    
  
    <div class="desc"><p>Maps elements in the underlying collection using function 
<code>f</code>:</p>
<pre><code>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).map(lambda x: x + 1).read()
[2, 3, 4, 5, 6]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.map', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.map" class="source">
    <pre><code>def map(self, f):
    """
    Maps elements in the underlying collection using function 
    `f`:
        >>> Dampr.memory([1,2,3,4,5]).map(lambda x: x + 1).read()
        [2, 3, 4, 5, 6]
    """
    def _map(k, v):
        yield k, f(v)
    return self._add_map(_map)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.mean">
    <p>def <span class="ident">mean</span>(</p><p>self, key=&lt;function PMap.&lt;lambda&gt; at 0x7fa514f380d0&gt;, value=&lt;function PMap.&lt;lambda&gt; at 0x7fa514f38158&gt;, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Finds the mean of X, grouped by its key function and optionally
mapped by a value function:</p>
<pre><code>&gt;&gt;&gt; ages = [("Andrew", 33), ("Alice", 42), ("Andrew", 12), ("Bob", 51)]
&gt;&gt;&gt; Dampr.memory(ages).mean(lambda x: x[0], lambda v: v[1]).read()
[('Alice', 42.0), ('Andrew', 22.5), ('Bob', 51.0)]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.mean', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.mean" class="source">
    <pre><code>def mean(self, key=lambda x: 1, value=lambda x: x, **options):
    """
    Finds the mean of X, grouped by its key function and optionally
    mapped by a value function:
        >>> ages = [("Andrew", 33), ("Alice", 42), ("Andrew", 12), ("Bob", 51)]
        >>> Dampr.memory(ages).mean(lambda x: x[0], lambda v: v[1]).read()
        [('Alice', 42.0), ('Andrew', 22.5), ('Bob', 51.0)]
    """
    def _mean_binop(x, y):
        return x[0] + y[0], x[1] + y[1]
    def _average(x):
        return (x[0], x[1][0] / float(x[1][1]))
    return self.a_group_by(key, lambda v: (value(v), 1)) \
            .reduce(_mean_binop, **options) \
            .map(_average)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.partition_map">
    <p>def <span class="ident">partition_map</span>(</p><p>self, f, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Provides a medium-level interface for writing custom functionality for mapping 
a partition.  This can be used for creating custom logic in mappers for the sake
of performance or additional functionality.</p>
<p>Note: partition_map will still execute even if the partition is empty!  Make sure
the logic handles empty sets!</p>
<p><code>f</code> is a function that takes in an iterator of items in the partition and yields 
out group keys and new values.</p>
<pre><code>&gt;&gt;&gt; def plus_one(items):
...   for num in items:
...     yield num, num + 1
...
&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).partition_map(plus_one).read()
[2, 3, 4, 5, 6]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.partition_map', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.partition_map" class="source">
    <pre><code>def partition_map(self, f, **options):
    """
    Provides a medium-level interface for writing custom functionality for mapping 
    a partition.  This can be used for creating custom logic in mappers for the sake
    of performance or additional functionality.
    Note: partition_map will still execute even if the partition is empty!  Make sure
    the logic handles empty sets!
    `f` is a function that takes in an iterator of items in the partition and yields 
    out group keys and new values.
        >>> def plus_one(items):
        ...   for num in items:
        ...     yield num, num + 1
        ...
        >>> Dampr.memory([1,2,3,4,5]).partition_map(plus_one).read()
        [2, 3, 4, 5, 6]
    """
    return self.custom_mapper(StreamMapper(f), **options)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.partition_reduce">
    <p>def <span class="ident">partition_reduce</span>(</p><p>self, f)</p>
    </div>
    

    
  
    <div class="desc"><p><code>partition_reduce</code> is a medium-level function that allows for more complex logic
during reductions.  It can be useful in certain cases where reductions over sets
of reduced values is convenient, such as returning only the top K items in a dataset</p>
<p>Note: <code>partition_reduce</code> will still execute on empty partitions!  Make sure the
logic handles cases where a partition is empty!</p>
<pre><code>&gt;&gt;&gt; def largest_number(it):
...   largest = float('-inf')
...   for group_key, its in it:
...     for value in its:
...       largest = max(largest, value)
...   yield "Largest", largest
...
&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).partition_reduce(largest_number).read(n_partitions=1)
[('Largest', 5)]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.partition_reduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.partition_reduce" class="source">
    <pre><code>def partition_reduce(self, f):
    """
    `partition_reduce` is a medium-level function that allows for more complex logic
    during reductions.  It can be useful in certain cases where reductions over sets
    of reduced values is convenient, such as returning only the top K items in a dataset
    Note: `partition_reduce` will still execute on empty partitions!  Make sure the
    logic handles cases where a partition is empty!
        >>> def largest_number(it):
        ...   largest = float('-inf')
        ...   for group_key, its in it:
        ...     for value in its:
        ...       largest = max(largest, value)
        ...   yield "Largest", largest
        ...
        >>> Dampr.memory([1,2,3,4,5]).partition_reduce(largest_number).read(n_partitions=1)
        [('Largest', 5)]
    """
    return self.custom_reducer(StreamReducer(f))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.read">
    <p>def <span class="ident">read</span>(</p><p>self, k=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Shorthand for run() followed by a read()</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.read', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.read" class="source">
    <pre><code>def read(self, k=None, **kwargs):
    """
    Shorthand for run() followed by a read()
    """
    return self.run(**kwargs).read(k)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.run">
    <p>def <span class="ident">run</span>(</p><p>self, name=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Run the defined graph.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.run', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.run" class="source">
    <pre><code>def run(self, name=None, **kwargs):
    """
    Run the defined graph.
    """
    if len(self.agg) > 0:
        return self.checkpoint().run(name, **kwargs)
    else:
        return super(PMap, self).run(name, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.sample">
    <p>def <span class="ident">sample</span>(</p><p>self, prob)</p>
    </div>
    

    
  
    <div class="desc"><p>Samples data with a given probability.  For example:</p>
<p><code>graph.sample(0.1)</code> will uniformly sample 10% of the data in the collection.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.sample', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.sample" class="source">
    <pre><code>def sample(self, prob):
    """
    Samples data with a given probability.  For example:
    
    `graph.sample(0.1)` will uniformly sample 10% of the data in the collection.
    """
    assert 0 <= prob <= 1.0
    def _sample(k, v):
        if get_rand().random() < prob:
            yield k, v
    return self._add_map(_sample)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.sink">
    <p>def <span class="ident">sink</span>(</p><p>self, path)</p>
    </div>
    

    
  
    <div class="desc"><p>Since writes each X in a collection to a given path.  The path will
create a directory and write each map or reduce partition into the
directory as partitions.  Sink assumes each X in the collection is 
already a unicode string.</p>
<pre><code>&gt;&gt;&gt; Dampr.memory(["foo", "bar", "baz"]).sink("/tmp/foo").run()
&gt;&gt;&gt; open("/tmp/foo/0").read()
&gt;&gt;&gt; open("/tmp/foo/1").read()
&gt;&gt;&gt; open("/tmp/foo/2").read()
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.sink', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.sink" class="source">
    <pre><code>def sink(self, path):
    """
    Since writes each X in a collection to a given path.  The path will
    create a directory and write each map or reduce partition into the
    directory as partitions.  Sink assumes each X in the collection is 
    already a unicode string.
        >>> Dampr.memory(["foo", "bar", "baz"]).sink("/tmp/foo").run()
        >>> open("/tmp/foo/0").read()
        >>> open("/tmp/foo/1").read()
        >>> open("/tmp/foo/2").read()
"""
    aggs = [Map(_identity)] if len(self.agg) == 0 else self.agg[:]
    name = ' -> ' .join('{}'.format(a.mapper.__name__) for a in aggs)
    name = 'Stage {}: %s' % (name)
    source, pmer = self.pmer._add_sink([self.source], 
            fuse(aggs), 
            path=path,
            name=name,
            options=None)
    return PMap(source, pmer) 
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.sink_json">
    <p>def <span class="ident">sink_json</span>(</p><p>self, path)</p>
    </div>
    

    
  
    <div class="desc"><p>A convenience function which takes a simple python object and serializes
it to a line-delimited json to the given path:</p>
<pre><code>&gt;&gt;&gt; Dampr.memory([{"name": "Hank Aaron", "home runs": 755}]).sink_json("/tmp/foo").run()
&gt;&gt;&gt; open("/tmp/foo/0").read()
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.sink_json', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.sink_json" class="source">
    <pre><code>def sink_json(self, path):
    """
    A convenience function which takes a simple python object and serializes
    it to a line-delimited json to the given path:
        >>> Dampr.memory([{"name": "Hank Aaron", "home runs": 755}]).sink_json("/tmp/foo").run()
        >>> open("/tmp/foo/0").read()
    """
    return self.map(json.dumps).sink(path)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.sink_tsv">
    <p>def <span class="ident">sink_tsv</span>(</p><p>self, path)</p>
    </div>
    

    
  
    <div class="desc"><p>A convenience function which takes a tuple or list, creates a simple
tab-delimited output, and sinks it to the provided path:</p>
<pre><code>&gt;&gt;&gt; Dampr.memory([("Hank Aaron", 755)]).sink_tsv("/tmp/foo").run()
&gt;&gt;&gt; open("/tmp/foo/0").read()
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.sink_tsv', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.sink_tsv" class="source">
    <pre><code>def sink_tsv(self, path):
    """
    A convenience function which takes a tuple or list, creates a simple
    tab-delimited output, and sinks it to the provided path:
        >>> Dampr.memory([("Hank Aaron", 755)]).sink_tsv("/tmp/foo").run()
        >>> open("/tmp/foo/0").read()
    """
    return self.map(lambda x: u'\t'.join(unicode(p) for p in x)).sink(path)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PMap.sort_by">
    <p>def <span class="ident">sort_by</span>(</p><p>self, key, **options)</p>
    </div>
    

    
  
    <div class="desc"><p>Sorts the results by a given key function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 1).sort_by(lambda x: -x).read()
[5, 3, 1]</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PMap.sort_by', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PMap.sort_by" class="source">
    <pre><code>def sort_by(self, key, **options):
    """
    Sorts the results by a given key function.
    
        >>> Dampr.memory([1,2,3,4,5]).filter(lambda x: x % 2 == 1).sort_by(lambda x: -x).read()
        [5, 3, 1]
    """
    def _sort_by(_key, value):
        yield key(value), value
    return self._add_map(_sort_by).checkpoint(options=options)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="dampr.PMap.agg" class="name">var <span class="ident">agg</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="dampr.PReduce" class="name">class <span class="ident">PReduce</span></p>
      
  
    <div class="desc"><p>A more general reduce class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce" class="source">
    <pre><code>class PReduce(PBase):
    """
    A more general reduce class.
    """

    def reduce(self, f):
        """
        Reduces a grouped set of items by f, which takes two arguments: the group key
        and an iterator lazily yield all items in the group.

            >>> Dampr.memory([1,2,3,4,5]).group_by(lambda x: x % 2).reduce(lambda k, it: sum(it)).read()
            [(0, 6), (1, 9)]
        """
        new_source, pmer = self.pmer._add_reducer([self.source], KeyedReduce(f))
        return PMap(new_source, pmer)

    def unique(self, key=lambda x: x):
        """
        Returns the unique set of items in the grouping.

            >>> names = [("Andrew", 1), ("Andrew", 1), ("Andrew", 2), ("Becky", 13)]
            >>> Dampr.memory(names).group_by(lambda x: x[0], lambda x: x[1]).unique().read()
            [('Andrew', [1, 2]), ('Becky', [13])]
        """
        def _uniq(k, it):
            seen = set()
            agg = []
            for v in it:
                fv = key(v)
                if fv not in seen:
                    seen.add(fv)
                    agg.append(v)

            return agg

        return self.reduce(_uniq)

    def join(self, other):
        """
        Performs a join between two datasets on a given key, returning a PJoin object.
        """
        assert isinstance(other, PBase)
        if isinstance(other, PMap):
            other = other.checkpoint(True)

        pmer = Dampr(self.pmer.graph.union(other.pmer.graph))
        return PJoin(self.source, pmer, other.source)

    def partition_reduce(self, f):
        """
        Provides medium-level functionality for partition reductions.  See 
        PMap.partition_reduce for more details.
        """
        reducer = StreamReducer(f)
        name = str(reducer)
        new_source, pmer = me.pmer._add_reducer([self.pm.source], 
                reducer, 
                name=name)

        return PMap(new_source, pmer)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#dampr.PReduce">PReduce</a></li>
          <li>dampr.dampr.PBase</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="dampr.PReduce.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, source, pmer)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce.__init__', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce.__init__" class="source">
    <pre><code>def __init__(self, source, pmer):
    assert isinstance(source, Source)
    self.source = source
    self.pmer = pmer
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PReduce.join">
    <p>def <span class="ident">join</span>(</p><p>self, other)</p>
    </div>
    

    
  
    <div class="desc"><p>Performs a join between two datasets on a given key, returning a PJoin object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce.join', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce.join" class="source">
    <pre><code>def join(self, other):
    """
    Performs a join between two datasets on a given key, returning a PJoin object.
    """
    assert isinstance(other, PBase)
    if isinstance(other, PMap):
        other = other.checkpoint(True)
    pmer = Dampr(self.pmer.graph.union(other.pmer.graph))
    return PJoin(self.source, pmer, other.source)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PReduce.partition_reduce">
    <p>def <span class="ident">partition_reduce</span>(</p><p>self, f)</p>
    </div>
    

    
  
    <div class="desc"><p>Provides medium-level functionality for partition reductions.  See 
PMap.partition_reduce for more details.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce.partition_reduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce.partition_reduce" class="source">
    <pre><code>def partition_reduce(self, f):
    """
    Provides medium-level functionality for partition reductions.  See 
    PMap.partition_reduce for more details.
    """
    reducer = StreamReducer(f)
    name = str(reducer)
    new_source, pmer = me.pmer._add_reducer([self.pm.source], 
            reducer, 
            name=name)
    return PMap(new_source, pmer)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PReduce.read">
    <p>def <span class="ident">read</span>(</p><p>self, k=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Shorthand for run() followed by a read()</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce.read', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce.read" class="source">
    <pre><code>def read(self, k=None, **kwargs):
    """
    Shorthand for run() followed by a read()
    """
    return self.run(**kwargs).read(k)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PReduce.reduce">
    <p>def <span class="ident">reduce</span>(</p><p>self, f)</p>
    </div>
    

    
  
    <div class="desc"><p>Reduces a grouped set of items by f, which takes two arguments: the group key
and an iterator lazily yield all items in the group.</p>
<pre><code>&gt;&gt;&gt; Dampr.memory([1,2,3,4,5]).group_by(lambda x: x % 2).reduce(lambda k, it: sum(it)).read()
[(0, 6), (1, 9)]
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce.reduce', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce.reduce" class="source">
    <pre><code>def reduce(self, f):
    """
    Reduces a grouped set of items by f, which takes two arguments: the group key
    and an iterator lazily yield all items in the group.
        >>> Dampr.memory([1,2,3,4,5]).group_by(lambda x: x % 2).reduce(lambda k, it: sum(it)).read()
        [(0, 6), (1, 9)]
    """
    new_source, pmer = self.pmer._add_reducer([self.source], KeyedReduce(f))
    return PMap(new_source, pmer)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PReduce.run">
    <p>def <span class="ident">run</span>(</p><p>self, name=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Evaluates the composed Dampr graph with the provided name and subsequent options.
By default, uses /tmp as temporary storage.</p>
<p>Returns a ValueEmitter useful for shell access.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce.run', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce.run" class="source">
    <pre><code>def run(self, name=None, **kwargs):
    """
    Evaluates the composed Dampr graph with the provided name and subsequent options.
    By default, uses /tmp as temporary storage.
    Returns a ValueEmitter useful for shell access.
    """
    if name is None:
        name = 'dampr/{}'.format(random.random())
    logging.debug("run source: %s", self.source)
    ds = self.pmer.runner(name, self.pmer.graph, **kwargs).run([self.source])
    return ValueEmitter(ds[0])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="dampr.PReduce.unique">
    <p>def <span class="ident">unique</span>(</p><p>self, key=&lt;function PReduce.&lt;lambda&gt; at 0x7fa514f388c8&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the unique set of items in the grouping.</p>
<blockquote>
<blockquote>
<blockquote>
<p>names = [("Andrew", 1), ("Andrew", 1), ("Andrew", 2), ("Becky", 13)]
Dampr.memory(names).group_by(lambda x: x[0], lambda x: x[1]).unique().read()
[('Andrew', [1, 2]), ('Becky', [13])]</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-dampr.PReduce.unique', this);">Show source &equiv;</a></p>
  <div id="source-dampr.PReduce.unique" class="source">
    <pre><code>def unique(self, key=lambda x: x):
    """
    Returns the unique set of items in the grouping.
        >>> names = [("Andrew", 1), ("Andrew", 1), ("Andrew", 2), ("Becky", 13)]
        >>> Dampr.memory(names).group_by(lambda x: x[0], lambda x: x[1]).unique().read()
        [('Andrew', [1, 2]), ('Becky', [13])]
    """
    def _uniq(k, it):
        seen = set()
        agg = []
        for v in it:
            fv = key(v)
            if fv not in seen:
                seen.add(fv)
                agg.append(v)
        return agg
    return self.reduce(_uniq)
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
